{"meta":{"title":"我一路向北","subtitle":null,"description":null,"author":"我一路向北","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-08-16T01:47:07.000Z","updated":"2017-08-16T01:47:46.547Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-08-16T01:48:13.000Z","updated":"2017-08-16T01:48:28.924Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack配置react开发环境","slug":"webpack配置react开发环境","date":"2017-07-25T11:32:15.000Z","updated":"2017-09-01T02:25:10.322Z","comments":true,"path":"2017/07/25/webpack配置react开发环境/","link":"","permalink":"http://yoursite.com/2017/07/25/webpack配置react开发环境/","excerpt":"","text":"","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"JavaScript 性能调优","slug":"JavaScript 性能调优","date":"2017-07-19T14:22:55.000Z","updated":"2017-09-01T02:18:49.715Z","comments":true,"path":"2017/07/19/JavaScript 性能调优/","link":"","permalink":"http://yoursite.com/2017/07/19/JavaScript 性能调优/","excerpt":"","text":"Web 开发中经常会遇到性能的问题，尤其是针对当今的 Web2.0 应用。JavaScript 是当今使用最为广泛的 Web 开发语言，Web 应用的性能问题很大一部分都是由程序员写的 JavaScript 脚本性能不佳所造成的，里面包括了 JavaScript 语言本身的性能问题，以及其与 DOM 交互时的性能问题。本文主要来探讨一下如何尽可能多的避免这类问题，从而最大限度的提高 Web 应用的性能。 JavaScript 性能调优JavaScript 语言由于它的单线程和解释执行的两个特点，决定了它本身有很多地方有性能问题，所以可改进的地方有不少。eval 的问题：比较下述代码： 1. eval 的问题12345var reference = &#123;&#125;, props = “p1”; eval(“reference.” + props + “=5”) var reference = &#123;&#125;, props = “p1”; reference[props] = 5 有eval的代码比没有eval的代码要慢上 100 倍以上。 主要原因是：JavaScript 代码在执行前会进行类似预编译的操作：首先会创建一个当前执行环境下的活动对象，并将那些用 var 申明的变量设置为活动对象的属性，但是此时这些变量的赋值都是 undefined，并将那些以 function 定义的函数也添加为活动对象的属性，而且它们的值正是函数的定义。但是，如果你使用了eval，则eval中的代码（实际上为字符串）无法预先识别其上下文，无法被提前解析和优化，即无法进行预编译的操作。所以，其性能也会大幅度降低。 2. function 的用法12345var func1 = new Function(“return arguments[0] + arguments[1]”);func1(10, 20); var func2 = function()&#123; return arguments[0] + arguments[1] &#125;;func2(10, 20); 这里类似之前提到的eval方法，这里func1的效率会比func2的效率差很多，所以推荐使用第二种方式。 3.函数的作用域链（scope chain）： JavaScript 代码解释执行，在进入函数内部时，它会预先分析当前的变量，并将这些变量归入不同的层级（level），一般情况下：局部变量放入层级 1（浅），全局变量放入层级 2（深）。如果进入with或try – catch代码块，则会增加新的层级，即将with或catch里的变量放入最浅层（层 1），并将之前的层级依次加深。 参考如下代码： 123456789101112var myObj = … .. … .. function process()&#123; var images = document.getElementsByTagName(&quot;img&quot;), widget = document.getElementsByTagName(&quot;input&quot;), combination = []; for(var i = 0; i &lt; images.length; i++)&#123; combination.push(combine(images[i], widget[2*i])); &#125; myObj.container.property1 = combination[0]; myObj.container.property2 = combination[combination.length-1]; &#125; 这里我们可以看到，images，widget，combination属于局部变量,在层 1。documen，myObj属于全局变量，在层 2。变量所在的层越浅，访问（读取或修改）速度越快，层越深，访问速度越慢。所以这里对images，widget，combination的访问速度比document，myObj要快一些。所以推荐尽量使用局部变量。 4. 使用局部变量123456789101112var myObj; function process()&#123; var doc = document; var images = doc.getElementsByTagName(&quot;img&quot;), widget = doc.getElementsByTagName(&quot;input&quot;), combination = []; for(var i = 0; i &lt; images.length; i++)&#123; combination.push(combine(images[i], widget[2*i])); &#125; myObj.container.property1 = combination[0]; myObj.container.property2 = combination[combination.length-1]; &#125; 我们用局部变量doc取代全局变量document，这样可以改进性能，尤其是对于大量使用全局变量的函数里面。 5. 慎用 with1234567891011121314var myObj;function process()&#123; var doc = document; var images = doc.getElementsByTagName(&quot;img&quot;), widget = doc.getElementsByTagName(&quot;input&quot;), combination = []; for(var i = 0; i &lt; images.length; i++)&#123; combination.push(combine(images[i], widget[2*i])); &#125; with (myObj.container) &#123; property1 = combination[0]; property2 = combination[combination.length-1]; &#125; &#125; 加上with关键字，我们让代码更加简洁清晰了，但是这样做性能会受影响。正如之前说的，当我们进入with代码块时，combination便从原来的层 1 变到了层 2，这样，效率会大打折扣。所以比较一下，还是使用原来的代码。 6. 改进 with123456789101112var myObj; function process()&#123; var doc = document; var images = doc.getElementsByTagName(&quot;img&quot;), widget = doc.getElementsByTagName(&quot;input&quot;), combination = []; for(var i = 0; i &lt; images.length; i++)&#123; combination.push(combine(images[i], widget[2*i])); &#125; myObj.container.property1 = combination[0]; myObj.container.property2 = combination[combination.length-1]; &#125; 但是这样并不是最好的方式，JavaScript 有个特点，对于 object 对象来说，其属性访问层级越深，效率越低，比如这里的myObj已经访问到了第 3 层，我们可以这样改进一下： 7. 缩小对象访问层级1234567891011121314var myObj = … .. … .. function process()&#123; var doc = document; var images = doc.getElementsByTagName(&quot;img&quot;), widget = doc.getElementsByTagName(&quot;input&quot;), combination = []; for(var i = 0; i &lt; images.length; i++)&#123; combination.push(combine(images[i], widget[2*i])); &#125; var ctn = myObj.container; ctn.property1 = combination[0]; ctn.property2 = combination[combination.length-1]; &#125; 我们用局部变量来代替“myObj”的第 2 层的“container”对象。如果有大量的这种对对象深层属性的访问，可以参照以上方式提高性能。字符串（String）相关字符串拼接经常看到这样的代码： 8. 字符串简单拼接1str += “str1” + “str2” 这是我们拼接字符串常用的方式，但是这种方式会有一些临时变量的创建和销毁，影响性能，所以推荐使用如下方式拼接 9. 字符串数组方式拼接1234var str_array = []; str_array.push(“str1”); str_array.push(“str2”); str = str_array.join(“”); 这里我们利用数组（array）的“join”方法实现字符串的拼接，尤其是程序的老版本的 Internet Explore（IE6）上运行时，会有非常明显的性能上的改进。当然，最新的浏览器（如火狐 Firefox3+，IE8+ 等等）对字符串的拼接做了优化，我们也可以这样写： 10. 字符串快速拼接12str +=“str1”str +=“str2” 新的浏览器对“+=”做了优化，性能略快于数组的“join”方法。在不久的将来更新版本浏览器可能对“+”也会做优化，所以那时我们可以直接写：str += “str1” + “str2”。隐式类型转换参考如下代码： 11. 隐式类型转换1234var str = “12345678”, arr = []; for(var i = 0; i &lt;= s.length; i++)&#123; arr.push( str.charAt(i)); &#125; 这里我们在每个循环时都会调用字符串的“charAt”方法，但是由于我们是将常量“12345678”赋值给“str”，所以“str”这里事实上并不是一个字符串对象，当它每次调用“charAt”函数时，都会临时构造值为“12345678”的字符串对象，然后调用“charAt”方法，最后再释放这个字符串临时对象。我们可以做一些改进： 12. 避免隐式类型转换1234var str = new Stirng(“12345678”), arr = []; for(var i = 0; i &lt;= s.length; i++)&#123; arr.push( str.charAt(i)); &#125; 这样一来，变量“str”作为一个字符串对象，就不会有这种隐式类型转换的过程了，这样一来，效率会显著提高。 13.字符串匹配JavaScript 有 RegExp 对象，支持对字符串的正则表达式匹配。是一个很好的工具，但是它的性能并不是非常理想。相反，字符串对象（String）本身的一些基本方法的效率是非常高的，比如“substring”，“indexOf”，“charAt”等等，在我们需要用正则表达式匹配字符串时，可以考虑一下：是否能够通过字符串对象本身支持的基本方法解决问题。是否可以通过“substring”来缩小需要用正则表达式的范围。这些方式都能够有效的提高程序的效率。关于正则表达式对象，还有一点需要注意，参考如下代码：1234for(var i = 0; i &lt;= str_array.length; i++)&#123; if(str_array[i].match(/^s*extra\\s/))&#123; &#125; &#125; 这里，我们往“match”方法传入“/^sextra\\s/”是会影响效率的，它会构建临时值为“/^sextra\\s/”的正则表达式对象，执行“match”方法，然后销毁临时的正则表达式对象。我们可以这样做： 14. 利用变量12345var sExpr = /^s*extra\\s/; for(var i = 0; i &lt;= str_array.length; i++)&#123; if(str_array[i].match(sExpr))&#123; &#125; &#125; 这样就不会有临时对象了。setTimeout 和 setInterval“setTimeout”和“setInterval”这两个函数可以接受字符串变量，但是会带来和之前谈到的“eval”类似的性能问题，所以建议还是直接传入函数对象本身。利用提前退出参考如下两段代码： 15. 利用提前退出1234567891011121314 // 代码 1var name = … .; var source = …… ; if(source.match(/ …… /))&#123; &#125; // 代码 2var name = … .; var source = …… ; if(name.indexOf( … ) &amp;&amp;source.match(/ …… /))&#123; &#125; 代码 2 多了一个对“name.indexOf( … )”的判断，这使得程序每次走到这一段时会先执行“indexOf”的判断，再执行后面的“match”，在“indexOf”比“match”效率高很多的前提下，这样做会减少“match”的执行次数，从而一定程度的提高效率。DOM 操作性能调优JavaScript 的开发离不开 DOM 的操作，所以对 DOM 操作的性能调优在 Web 开发中也是非常重要的。Repaint 和 ReflowRepaint 也叫 Redraw，它指的是一种不会影响当前 DOM 的结构和布局的一种重绘动作。如下动作会产生 Repaint 动作：不可见到可见（visibility 样式属性）颜色或图片变化（background, border-color, color 样式属性）不改变页面元素大小，形状和位置，但改变其外观的变化Reflow 比起 Repaint 来讲就是一种更加显著的变化了。它主要发生在 DOM 树被操作的时候，任何改变 DOM 的结构和布局都会产生 Reflow。但一个元素的 Reflow 操作发生时，它的所有父元素和子元素都会放生 Reflow，最后 Reflow 必然会导致 Repaint 的产生。举例说明，如下动作会产生 Repaint 动作：浏览器窗口的变化DOM 节点的添加删除操作一些改变页面元素大小，形状和位置的操作的触发减少 Reflow通过 Reflow 和 Repaint 的介绍可知，每次 Reflow 比其 Repaint 会带来更多的资源消耗，我们应该尽量减少 Reflow 的发生，或者将其转化为只会触发 Repaint 操作的代码。参考如下代码： 16. reflow 介绍123456var pDiv = document.createElement(“div”); document.body.appendChild(pDiv);----- reflowvar cDiv1 = document.createElement(“div”); var cDiv2 = document.createElement(“div”); pDiv.appendChild(cDiv1);----- reflowpDiv.appendChild(cDiv2);----- reflow 这是我们经常接触的代码了，但是这段代码会产生 3 次 reflow。再看如下代码： 17. 减少 reflow123456var pDiv = document.createElement(“div”); var cDiv1 = document.createElement(“div”); var cDiv2 = document.createElement(“div”); pDiv.appendChild(cDiv1); pDiv.appendChild(cDiv2); document.body.appendChild(pDiv);----- reflow 这里便只有一次 reflow，所以我们推荐这种 DOM 节点操作的方式。关于上述较少 Reflow 操作的解决方案，还有一种可以参考的模式： 18. 利用 display 减少 reflow123456789101112var pDiv = document.getElementById(“parent”); pDiv.style.display = “none”----- reflow pDiv.appendChild(cDiv1); pDiv.appendChild(cDiv2); pDiv.appendChild(cDiv3); pDiv.appendChild(cDiv4); pDiv.appendChild(cDiv5); pDiv.style.width = “100px”; pDiv.style.height = “100px”; pDiv.style.display = “block”----- reflow 先隐藏 pDiv，再显示，这样，隐藏和显示之间的操作便不会产生任何的 Reflow，提高了效率。特殊测量属性和方法DOM 元素里面有一些特殊的测量属性的访问和方法的调用，也会触发 Reflow，比较典型的就是“offsetWidth”属性和“getComputedStyle”方法。图 1. 特殊测量属性和方法图 1. 特殊测量属性和方法这些测量属性和方法大致有这些：offsetLeftoffsetTopoffsetHeightoffsetWidthscrollTop/Left/Width/HeightclientTop/Left/Width/HeightgetComputedStyle()currentStyle(in IE))这些属性和方法的访问和调用，都会触发 Reflow 的产生，我们应该尽量减少对这些属性和方法的访问和调用，参考如下代码： 19. 特殊测量属性1234567var pe = document.getElementById(“pos_element”); var result = document.getElementById(“result_element”); var pOffsetWidth = pe.offsetWidth; result.children[0].style.width = pOffsetWidth; result.children[1].style.width = pOffsetWidth; result.children[2].style.width = pOffsetWidth; …………其他修改………… 这里我们可以用临时变量将“offsetWidth”的值缓存起来，这样就不用每次访问“offsetWidth”属性。这种方式在循环里面非常适用，可以极大地提高性能。样式相关我们肯定经常见到如下的代码： 20. 样式相关12345var sElement = document.getElementById(“pos_element”); sElement.style.border = ‘ 1px solid red ’sElement.style.backgroundColor = ‘ silver ’sElement.style.padding = ‘ 2px 3px ’sElement.style.marginLeft = ‘ 5px ’ 但是可以看到，这里的每一个样式的改变，都会产生 Reflow。需要减少这种情况的发生，我们可以这样做：解决方案 1： className 解决方案1234567.class1 &#123; border: ‘ 1px solid red ’background-color: ‘ silver ’padding: ‘ 2px 3px ’margin-left: ‘ 5px ’&#125; document.getElementById(“pos_element”).className = ‘class1’ ; 用 class 替代 style，可以将原有的所有 Reflow 或 Repaint 的次数都缩减到一个。解决方案 2： cssText 解决方案1234var sElement = document.getElementById(“pos_element”); var newStyle = ‘ border: 1px solid red; ’ + ‘ background-color: silver; ’ + ‘ padding: 2px 3px; ’ + “margin-left: 5px;”sElement.style.cssText += newStyle; 一次性设置所有样式，也是减少 Reflow 提高性能的方法。 21.动态创建 script 标签加载并执行一段 JavaScript 脚本是需要一定时间的，在我们的程序中，有时候有些 JavaScript 脚本被加载后基本没有被使用过 （比如：脚本里的函数从来没有被调用等等）。加载这些脚本只会占用 CPU 时间和增加内存消耗，降低 Web 应用的性能。所以推荐动态的加载 JavaScript 脚本文件，尤其是那些内容较多，消耗资源较大的脚本文件。123456if(needXHR)&#123; document.write(“&lt;script type= ’ test\\/JavaScript ’ src= &apos;dojo_xhr.js&apos; &gt;”); &#125; if(dojo.isIE)&#123; document.write(“&lt;script type= ’ test\\/JavaScript ’ src= &apos;vml.js&apos; &gt;”); &#125; 结束语最后，总结下常见的dom操作的优化方法（节选自高性能JavaScript） 1 最小化dom访问次数，尽可能在js端执行； 2 如果需要多次访问某个dom节点，请使用局部变量存储对它的引用； 3 小心处理html集合，因为它实时连系着底层的文档，把集合的长度缓存到一个变量中，并在迭代中使用它，如果需要经常操作集合，建议把它拷贝到一个数组中； 4 如果可能的话，使用速度更快的API，比如querySelectorAll和firstElementChild； 5 要留意重绘和重排；批量修改样式时，“离线”操作dom树；使用缓存，并减少访问布局的次数； 6 动画中使用绝对定位，使用拖放代理 7 使用事件委托来减少事件处理器的数量 总结下js中对数据访问的优化（节选自高性能JavaScript） 1 函数中读写局部变量总是最快的，而全局变量的读取则是最慢的； 2 尽可能地少用with 语句，因为它会增加with 语句以外的数据的访问代价； 3 闭包尽管强大，但不可滥用，否则会影响到执行速度以及内存； 4 嵌套的对象成员会明显影响性能，尽量少用； 5 避免多次访问对象成员或函数中的全局变量，尽量将它们赋值给局部变量以缓存。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"React 全家桶实现后台管理界面","slug":"react 全家桶实现后台管理界面","date":"2017-06-29T13:12:55.000Z","updated":"2017-09-01T01:35:55.612Z","comments":true,"path":"2017/06/29/react 全家桶实现后台管理界面/","link":"","permalink":"http://yoursite.com/2017/06/29/react 全家桶实现后台管理界面/","excerpt":"","text":"React 全家桶实现后台管理界面一、实验介绍1.1 实验内容React 是一个 Facebook 和 Instagram 用来创建用户界面的 JavaScript 库。创造 React 是为了解决一个问题：构建随着时间数据“不断变化”的“大规模”应用程序。本课程虽然使用了前端框架 antd，从零开始构建一个 React 后台管理界面，并结合 React+React-Router+React-Redux 实现页面功能，加深对 React 全家桶的理解及运用。 1.2 实验知识点 webpack 基础配置及使用 React 构建项目流程 Redux 简介及基础使用 UI框架 antd 的基本使用 axios 的基本使用 json-server 模拟后台数据接口 1.3 实验环境 node.js centos 1.4 适合人群本课程难度为一般，属于初级级别课程，适合具有React基础的用户，熟悉React基础知识加深巩固。 1.5 代码获取你可以通过下面命令将代码下载到实验楼环境中，作为参照对比进行学习。 1$ wget http://labfile.oss.aliyuncs.com/courses/857/react.zip 代码下载完成后解压并进入项目目录执行一下命令就能项目就能跑起来，打开浏览器输入127.0.0.1:3005,就能看到效果 123456$ unzip react.zip$ cd react $ npm i #这步较慢请耐心等待$ npm run dev$ sudo npm install json-server -g$ npm run server 二、实验原理由于React 中组件间通信是单向数据流， 当项目中组件嵌套复杂时，子组件向父组件通信数据传递就变得非常复杂。所以 Fackbook 提出 Flux 来管理 React 的数据流，后续又出现不同的架构，通过对比发现 Redux 相对其他的更为简化。但 Redux 和 React 是没有必然关系的，Redux 仅仅是用于管理 state。 Redux 主要的组成部分为: Action，Reducer，Store。Redux 的执行流程：首先需要注册一个全局唯一的store对象，用来维护整个应用的state；当要变更state时，我们会dispatch一个action，reducer根据action更新相应的state。 Aciton 它可以理解为一个载体，是数据从应用传递到store的载体，其中 type 是必备的一个字段，用来标识类型。 1234567//在页面中可引入这个函数并调用，产生新的stateexport function GetUserDetail(userDetail,totalElements,currentPage)&#123; return&#123; type: GET_USER_DETAIL, userDetail,totalElements,currentPage &#125;&#125; Reducer 实际上就是一个函数，需要传入两个参数 state action，用来修改store的状态。本课程新建一个rootReducer.js来统一管理 1234567891011121314151617//定义初始statevar init=&#123; userDetail:[],//保存从后台传递的数据 usercount: 0, totalElements:0, currentPage:0, userOne:&apos;&apos;,&#125;;export default function user(state=init,action)&#123; switch(action.type)&#123; //case 后的名称必须与action中type保持一致 case GET_USER_DETAIL: return Object.assign(&#123;&#125;,state,&#123;userDetail:action.userDetail,totalElements:action.totalElements,currentPage:action.currentPage&#125;); default : return state; &#125;&#125; Store 是一个全局对象，用来维护 state 状态的，主要有两个方法 store.getState() 获取最近内部的 state，store.dispatch(action) 连接 action，reducer 与 state。 12345678// 引入总的rootReducerimport rootReducer from &quot;../reducers/rootReducer&quot;;// 引入redux，包含中间件import &#123; createStore,applyMiddleware &#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;const store=createStore(rootReducer, applyMiddleware(thunk));export default store; React-Redux 是一个轻量级的库，核心的方法只有 Provider 与 connect。 Provider 的功能主要包含以下两点： 包裹原应用组件的最外层，使整个应用成为成为其子组件 接收 Redux 的 store 作为 props，通过context对象传递给子孙组件 connect 是真正链接 React 和 Redux 的模块 三、开发准备打开Xfce终端，进入 Code 目录，创建 react 文件夹, npm的下载速度较慢，我们修改npm源，这个步骤比较慢，请大家耐等待(如已经了解安装的同学，可直接下载项目的package.json放到自己的项目，npm install),安装完成之后 cnpm -v 查看是否安装成功。 123$ mkdir react &amp;&amp; cd react$ sudo npm config set registry https://registry.npm.taobao.org$ sudo npm info underscore 初始化 package.json 执行以下命令后，一直按enter键，如果需要对于项目名称，作者等信息进行修改，根据提示做相应的操作。 1$ npm init 安装 webpack 并在根目录下创建并配置 webpack.config.js 文件 webpck 需要全局和本地同时安装。 12$ sudo npm install webpack -g$ sudo npm install webpack --save-dev webpack.config.js 123456789101112131415161718192021222324252627282930var path = require(&apos;path&apos;);var webpack = require(&apos;webpack&apos;);//__dirname是node.js中的一个全局变量，它指向当前执行脚本所在的目录module.exports = &#123; devtool: &apos;eval-source-map&apos;, //生成Source Maps,这里选择eval-source-map entry:[&apos;webpack/hot/dev-server&apos;, path.resolve(__dirname, &apos;./app/index.js&apos;)], //唯一入口文件 output: &#123; //输出目录 path: __dirname + &quot;/build&quot;, //打包后的js文件存放的目录 filename: &apos;bundle.js&apos;, //打包后的js文件名 &#125;, module: &#123; loaders: [&#123; test: /\\.jsx?$/, exclude: /node_modules/, //屏蔽不需要处理的文件（文件夹）（可选） loader: &apos;babel-loader&apos; &#125;, &#123; test: /\\.css$/, loader: &apos;style-loader!css-loader&apos; &#125;, &#123; test: /\\.less$/, loader: &apos;style-loader!css-loader!less-loader&apos; &#125;, &#123; test: /\\.(png|jpg)$/, loader: &apos;url-loader?limit=25000&apos; &#125;] &#125;, plugins: [//热刷新 new webpack.HotModuleReplacementPlugin() ],&#125;; 四、项目文件结构根据文件结构新建初步项目目录 12$ mkdir app build$ cd app mkdir actions reducers components store style views 12345678910111213141516171819202122232425262728├── app 源码目录，在这个目录下做开发│ ├── actions 存储可以发出的 action│ │ ├── ajax.js 自主封装ajax│ │ ├── login.js 控制登录验证│ │ └── user.js user的增删改查获取，弹出框控制action│ ├── components 普通组件目录(如，弹出表单组件)│ │ └── User│ │ └── AlertUser.js 编辑添加弹出Form框组件│ ├── index.js 入口文件，路由配置文件│ ├── reducers 存放action的处理器reducers│ │ ├── rootReducer.js│ │ └── user.js│ ├── store 全局 store 存储目录│ │ └── store.js│ ├── style 样式目录│ │ └── index.css│ └── views 容器组件存放目录│ ├── Index.js│ ├── Login.js│ ├── Menu.js│ └── User.js├── build 打包后文件存储目录及模板文件存放位置 │ ├── bundle.js│ └── index.html├── .babelrc babel配置文件(默认隐藏)├── db.json 模拟后台数据├── package.json npm配置文件└── webpack.config.js webpack配置文件 五、实验步骤5.1 安装 React 的系列依赖本课程 react-router 的版本使用3.0.5，redux-thunk 一个中间件，可以让action创建函数先不返回一个action对象，而是返回一个函数，函数传递两个参数(dispatch,getState),在函数体内进行业务逻辑的封装。 1$ sudo npm install --save-dev react react-dom redux react-redux react-router@3.0.5 react-redux-router redux-thunk 5.2 安装 Babel 并在根目录下创建并配置 .babelrc 文件使用JSX，可以极大的简化React元素的创建，其语法风格类似于HTML语法风格，让习惯html的人更容易理解。但浏览器引擎并不能识别JSX语法，而 Babel 可以Jsx语法转化为可是别的。这只是 Babel 的一个作用，它还会将ES6,ES7转化为能识别的ES*。 1$ sudo npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react .babelrc (在react目录下新建) 123456&#123; &quot;presets&quot;:[ &quot;es2015&quot;, &quot;react&quot; ]&#125; 5.3 安装 webpack 所需要的 loader现今浏览器引擎不能是被 react 的 JSX 语法，需通过Babel 1$ sudo npm install --save-dev babel-loader css-loader less-loader style-loader url-loader file-loader 5.4 安装 webpack-dev-server1$ sudo npm install --save-dev webpack-dev-server 安装完成后在 webpack.config.js 的 module 中添加devServer 123456devServer: &#123; contentBase: &quot;./build&quot;, //默认webpack-dev-server会为根文件夹提供本地服务器，本实例设置 build 目录 historyApiFallback: true, //开发单页应用时，如果设置为true，所有的跳转将指向index.html inline: true, //设置为true，自动刷新页面 port: 3001, //设置默认监听端口,默认为&quot;8080&quot;&#125; 需在package.json 文件的 scripts 中添加 build 及 dev 以后直接使用 npm run dev 就能开启页面查看实现效果，并能实现热刷新 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;: &quot;webpack-dev-server --devtool eval --progress --colors --content-base build&quot;, &#125; 5.5 安装并配置 json-server 模拟后台数据接口json-server 使用第三方库真实化模拟数据,但是数据传输的端口及 config 文件需要手动配置，这里为了方便后续使用我们在 package.json 文件的 scripts 中添加 server 后续使用 npm run server 就能开启后台数据接口。 123&quot;scripts&quot;: &#123; &quot;server&quot;: &quot;json-server db.json -w -p 3000&quot; &#125; 终端执行 12$ sudo npm install json-server --save-dev $ vi db.json db.json 因为是用户列表，所以初步设计的用户信息包含 id(唯一值)，name，age，email，user_type(识别用户身份，0-普通用户，1-标准会员，2-高级会员)文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; &quot;user&quot;: [ &#123; &quot;name&quot;: &quot;大毛&quot;, &quot;username&quot;: &quot;admin&quot;, &quot;email&quot;: &quot;123456@qq.com&quot;, &quot;password&quot;: &quot;000000&quot;, &quot;user_type&quot;: 2, &quot;id&quot;: 1 &#125;, &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;王二麻子&quot;, &quot;age&quot;: 18, &quot;email&quot;: &quot;123@qq.com&quot;, &quot;user_type&quot;: 0, &quot;username&quot;: &quot;admin1&quot;, &quot;password&quot;: 123456789 &#125;, &#123; &quot;name&quot;: &quot;张三&quot;, &quot;username&quot;: &quot;admin3&quot;, &quot;email&quot;: &quot;123@qq.com&quot;, &quot;password&quot;: &quot;000000&quot;, &quot;user_type&quot;: 2, &quot;id&quot;: 3 &#125;, &#123; &quot;name&quot;: &quot;admin&quot;, &quot;username&quot;: &quot;admin4&quot;, &quot;email&quot;: &quot;123@123456.com&quot;, &quot;password&quot;: &quot;000000&quot;, &quot;user_type&quot;: 0, &quot;id&quot;: 4 &#125;, &#123; &quot;name&quot;: &quot;aaaa&quot;, &quot;username&quot;: &quot;aaaa&quot;, &quot;email&quot;: &quot;aaa@11.com&quot;, &quot;password&quot;: &quot;222222&quot;, &quot;user_type&quot;: 0, &quot;id&quot;: 5 &#125;, &#123; &quot;name&quot;: &quot;ffff&quot;, &quot;username&quot;: &quot;222@qq.com&quot;, &quot;email&quot;: &quot;222@qq.com&quot;, &quot;password&quot;: &quot;000000&quot;, &quot;user_type&quot;: 1, &quot;id&quot;: 7 &#125; ]&#125; 5.6 antd axios 的简介及安装Ant Design 简称antd，是蚂蚁金服开发并正在使用的一套企业级的前端设计语言和基于 React 的前端框架实现，用于构建丰富的交互式用户界面。其官网地址：https://ant.design/docs/react/introduce/. axios 是一个基于Promise 的 HTTP 客户端，可同时在浏览器和 node.js 中使用。参考：https://www.npmjs.com/package/axios 1$ npm install antd axios --save-dev 5.7 新建模板文件 index.html12$ cd build $ vi index.html index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;React Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--要插入React组件的位置--&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;!-- 引入打包后的文件(相对路径) --&gt; &lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&lt;/html&gt; 5.6 新建入口文件 index.js 并利用 react-router 构建本项目的路由首先，本项目实现的页面包含:登录，首页，用户列表 三个页面，所以在构建路由时需要实现页面间的跳转。 12$ cd app $ vi index.js index.js 12345678910111213141516171819202122232425262728293031323334353637//引入react,react-domimport React from &apos;react&apos;;import &#123; render &#125; from &apos;react-dom&apos;;// 引入React-Router模块//引入react,react-domimport React from &apos;react&apos;;import &#123; render &#125; from &apos;react-dom&apos;;import &#123; Provider&#125;from &quot;react-redux&quot;;// 引入React-Router模块import &#123; Router, Route, Link, hashHistory, IndexRoute &#125; from &apos;react-router&apos;;import store from &quot;./store/store&quot;;// 全局引入Ant-Design样式import &quot;antd/dist/antd.min.css&quot;;//引入全局样式import &apos;./style/index.css&apos;//引入自定义组件import Login from &quot;./views/Login&quot;;//登录页面import User from &quot;./views/User&quot;//用户列表import Menu from &quot;./views/Menu&quot;//侧边栏菜单import Index from &quot;./views/Index&quot;//欢迎页面// 配置路由render(( &lt;Provider store=&#123;store&#125;&gt; &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=&quot;/login&quot; component=&#123;Login&#125; /&gt; &lt;Route path=&quot;/&quot; component=&#123;Menu&#125; &gt; &lt;IndexRoute component=&#123;Index&#125;/&gt; &lt;Route path=&quot;user&quot; component=&#123;User&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt; &lt;/Provider&gt;),document.getElementById(&apos;content&apos;)); 5.6 构建页面本课程主要的页面包含4个，登录页面，菜单页，首页及用户列表页面,页面的代码实现都在views目录下。主要的业务逻辑用户列表，包含查询，添加，编辑，删除。而编辑与新建时弹出的模态框封装在 components 目录下. 首先我们需要构建一个全局的store用于管理state，在app/store 目录下创建 store.js 12345678// 引入总的rootReducerimport rootReducer from &quot;../reducers/rootReducer&quot;;// 引入redux，包含中间件import &#123; createStore,applyMiddleware &#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;const store=createStore(rootReducer, applyMiddleware(thunk));export default store; 在app/reducers构建一个总的reducer管理文件rootReduce.js 123456789import &#123; combineReducers&#125; from &quot;redux&quot;;//引入每个页面的reducerimport user from &quot;./user&quot;;var rootReducer=combineReducers(&#123; user,&#125;);export default rootReducer; 做到这里，我们就可以根据路由引入文件在 view 目录下编写自己的页面，如果需要有行为,如:增加，需在action目录下创建，如页面内需要使用到 state 信息，需要reducers目录对应创建，详细需根据项目创建。以下是以编辑功能作为实例进行介绍。 User.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &#123; userOneFun,showModal,&#125; from &quot;../actions/user&quot;;import &#123; connect&#125; from &quot;react-redux&quot;;//引入弹出框Form表单import AlertUser from &quot;../components/User/AlertUser&quot;class User extends React.Component &#123; //编辑用户 toEdit(id) &#123; //获取单行数据,存储在userOne中 this.props.dispatch(userOneFun(id)); //显示弹出框 this.props.dispatch(showModal(true)); &#125;&#125; render() &#123; const columns = [&#123; title: &apos;操作&apos;, key: &apos;action&apos;, render: (text, record) =&gt; (//record表示单行数据 &lt;span &gt; &lt;Button onClick=&#123;()=&gt;this.toEdit(record.id)&#125;&gt; 编辑 &lt;/Button&gt; &lt;/span &gt; ), &#125; ] return( &lt;Layout&gt; &lt;Content&gt; &#123;/* AlertUser组件 */&#125; &lt;AlertUser /&gt; &lt;/Content&gt; &lt;/Layout&gt; ) &#125;function select(state)&#123; return&#123; userOne:state.user.userOne, &#125;&#125;//导出组件export default connect(select) (User); actions user.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//ajax是自主封装的文件import * as Ajax from &apos;./ajax&apos;;//定义常量export const GET_USER_DETAIL = &quot;GET_USER_DETAIL&quot;export const GET_USER_ONE = &quot;GET_USER_ONE&quot;export const GET_MODAL_SHOW = &quot;GET_MODAL_SHOW&quot;//获取所有用户列表export function GetUserDetail(userDetail,totalElements,currentPage)&#123; return&#123; type:GET_USER_DETAIL, userDetail,totalElements,currentPage &#125;&#125;export function ascyGetDetails(data)&#123; return function (dispatch)&#123; Ajax.getAjax(&quot;http://localhost:3000/user&quot;,function(response)&#123; if (response.data) &#123; let number = 1; if (data) &#123; number = data.page &#125; dispatch(GetUserDetail(response.data,response.data.length,number)); &#125; else &#123; dispatch(GetUserDetail([],0,1)); &#125; &#125;); &#125;&#125;//新增与修改用户，通过有无id判断是添加还是删除export function AddUser(data)&#123; return function (dispatch)&#123; if (data.id) &#123; Ajax.putAjax(&quot;http://localhost:3000/user/&quot;+data.id,data,function(response)&#123; if(response.data)&#123; //成功后刷新页面 dispatch(ascyGetDetails()); //成功后关闭form弹出框 dispatch(showModal(false)); &#125; &#125;); &#125; else &#123; Ajax.postAjax(&quot;http://localhost:3000/user&quot;,data,function(response)&#123; if(response.data)&#123; dispatch(ascyGetDetails()); dispatch(showModal(false)); &#125; &#125;); &#125; &#125;&#125;//点击编辑时获取每行数据function getUserone(userOne)&#123; return&#123; type:GET_USER_ONE, userOne &#125;&#125;export function userOneFun(id)&#123; return function (dispatch)&#123; Ajax.getAjax(&quot;http://localhost:3000/user/&quot;+id,function(response)&#123; if(response.data)&#123; //将返回的每行数据传给getUserone dispatch(getUserone(response.data)); &#125; &#125;); &#125;&#125;//新增或编辑时控制弹出框的显示与隐藏,将状态值保存至modaldisplay中export function showModal(modaldisplay)&#123; return&#123; type:GET_MODAL_SHOW, modaldisplay &#125;&#125; reducers user.js 链接 action 和 store, 根据不同的action返回不同state 123456789101112131415161718192021222324import &#123; GET_USER_DETAIL, GET_USER_ONE,GET_MODAL_SHOW &#125; from &apos;../actions/user&apos;//初始statelet init=&#123; userDetail:[], totalElements:0, currentPage:0, userOne:&apos;&apos;, modaldisplay:false&#125;;export default function user(state=init,action)&#123; switch(action.type)&#123; //用户的所有信息，用于开始的展示 case GET_USER_DETAIL: return Object.assign(&#123;&#125;,state,&#123;userDetail:action.userDetail,totalElements:action.totalElements,currentPage:action.currentPage&#125;); //点击编辑时，取得当前用户信息 case GET_USER_ONE: return Object.assign(&#123;&#125;,state,&#123;userOne:action.userOne&#125;); //控制弹出框的显示与隐藏 case GET_MODAL_SHOW: return Object.assign(&#123;&#125;,state,&#123;modaldisplay:action.modaldisplay&#125;); default : return state; &#125;&#125; 六、实验总结本课程基于 React 全家桶进行了简单项目的构建，从零开始搭建项目不仅能回顾基础知识，引入 Redux 也解决了我们单个 React 项目中的组件间通信困难的问题，加深对 React 项目的理解及使用，学会使用 antd UI框架，能更快节省开发周期，本课程设计的 antd 组件较少，可以根据官网API自主学习。 八、参考链接Redux中文文档 antd参考文档 axiosAPI 文章引用自实验楼，转载请注明来源","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"你真的知道JavaScript吗","slug":"你真的了解JS吗？","date":"2017-02-18T11:12:11.000Z","updated":"2017-08-21T10:10:28.601Z","comments":true,"path":"2017/02/18/你真的了解JS吗？/","link":"","permalink":"http://yoursite.com/2017/02/18/你真的了解JS吗？/","excerpt":"","text":"你真的知道JavaScript吗 JavaScript是一门奇怪的语言，要真正掌握并不容易。废话不多说，来一个快速测试，5道题目，看看你对JavaScript是否真正掌握。准备好了吗？开始咯😄 题目No.112345if (!(&quot;a&quot; in window)) &#123; var a = 1;&#125;console.log(a); No.212345var a = 1, b = function a(x) &#123; x &amp;&amp; a(--x); &#125;;console.log(a); No.312345function a(x) &#123; return x * 2;&#125;var a;console.log(a); No.412345function b(x, y, a) &#123; arguments[2] = 10; console.log(a);&#125;b(1, 2, 3); No.51234function a() &#123; console.log(this);&#125;a.call(null); 解析No.1在浏览器环境中，全局变量都是`window`的一个属性，即 var a = 1 等价于 window.a = 1。in操作符用来判断某个属性属于某个对象，可以是对象的直接属性，也可以是通过prototype继承的属性。 再看题目，在浏览器中，如果没有全局变量 a ，则声明一个全局变量 a (ES5没有块级作用域)，并且赋值为1。很多人会认为打印的是1。非也，大家不要忘了变量声明会被前置！什么意思呢？题目也就等价于 1234567var a;if (!(&quot;a&quot; in window)) &#123; a = 1;&#125;console.log(a); 所以其实已经声明了变量a，只不过if语句之前值是undefined，所以if语句压根不会执行。最后答案就是 undefined No.2这道题有几个需要注意的地方： 变量声明、函数声明会被前置，但是函数表达式并不会，准确说类似变量声明前置，举个栗子： 123console.log(&apos;b&apos;, b); // b undefinedvar b = function() &#123;&#125;console.log(&apos;b&apos;, b); // b function () &#123;&#125; 2.具名的函数表达式的名字只能在该函数内部取到，举个例子(排除老的IE😂)： 1234567var foo = function bar () &#123;&#125;console.log(&apos;foo&apos;, foo); // foo function bar()&#123;&#125;console.log(&apos;bar&apos;, bar);// Uncaught ReferenceError: bar is not defined 综合这两点，再看题目，最后输出的内容就为 1 No.3函数声明会覆盖变量声明，但不会覆盖变量赋值，举个栗子简单粗暴： 12345function foo()&#123; return 1;&#125;var foo;console.log(typeof foo); // &quot;function&quot; 函数声明的优先级高于变量声明的优先级，但如果该变量foo赋值了，那结果就完全不一样了： 12345function foo()&#123; return 1;&#125;var foo = 1;console.log(typeof foo); // &quot;number&quot; 变量foo赋值以后，变量赋值初始化就覆盖了函数声明。这个需要注意再看题目 12345function a(x) &#123; return x * 2;&#125;var a;console.log(a); // function a(x) &#123;...&#125; No.4这题考察 arguments 对象的用法(详看👉JavaScript中的arguments对象)一般情况，arguments与函数参数是动态绑定关系(为什么说是一般稍后会解释)，所以很好理解，最后输出的是10 但是但是但是，我们不要忘了一个特殊情况–严格模式，在严格模式中 arguments 与相当于函数参数的一个拷贝，并没有动态绑定关系，举个栗子： 12345678&apos;use strict&apos;// 严格模式！！function b(x, y, a) &#123; arguments[2] = 10; console.log(a);&#125;b(1, 2, 3); // 3 No.51234function a() &#123; console.log(this);&#125;a.call(null); 关于 a.call(null); 根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined的话，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管你什么时候传入null或者 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。 但是但是但是，我们依旧不能忘记一个特殊情况–严格模式，在严格模式中，null 就是 null，undefined 就是 undefined ，举个栗子： 12345678&apos;use strict&apos;;// 严格模式！！function a() &#123; console.log(this);&#125;a.call(null); // nulla.call(undefined); // undefined 提醒 在浏览器中的全局对象是window，Node.js中是global; 为了使代码更加严谨与健壮，建议写JS都加上严格模式&#39;use strict&#39;; ES6已经成为前端必备技能，呼吁大家都使用ES6，方便高效，可以使用babel把ES6转成ES5甚至ES3，尽量使用ES6推动前端的发展👍","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"原生JS中CSS相关API合集","slug":"原生JS中CSS相关API合集","date":"2017-02-14T07:12:11.000Z","updated":"2017-08-21T10:06:25.691Z","comments":true,"path":"2017/02/14/原生JS中CSS相关API合集/","link":"","permalink":"http://yoursite.com/2017/02/14/原生JS中CSS相关API合集/","excerpt":"","text":"原生JS中CSS相关API合集类名操作12345678910111213141516171819//ie8以下Element.className //获取元素节点的类名Element.className += &apos; &apos; + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className)&#123; return new RegExp(className,&apos;gi&apos;).test(element.className);&#125;//移除classfunction removeClass(element,className)&#123; element.className = element.className.replace(new RegExp(&apos;(^|\\\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\\\b|$)&apos;, &apos;gi&apos;),&apos;&apos;);&#125;//ie10 element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class style操作1234567891011121314151617element.setAttribute(&apos;style&apos;,&apos;&apos;)element.style.backgroundColor = &apos;red&apos;element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,&apos;:after&apos;)[attrName]","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"ES6编程风格","slug":"ES6编码风格","date":"2017-02-12T08:12:11.000Z","updated":"2017-08-21T09:52:30.892Z","comments":true,"path":"2017/02/12/ES6编码风格/","link":"","permalink":"http://yoursite.com/2017/02/12/ES6编码风格/","excerpt":"","text":"ES6编程风格编程风格本章探讨如何将ES6的新语法，运用到编码实践之中，与传统的JavaScript语法结合在一起，写出合理的、易于阅读和维护的代码。 多家公司和组织已经公开了它们的风格规范，具体可参阅jscs.info，下面的内容主要参考了Airbnb的JavaScript风格规范。 块级作用域（1）let 取代 var ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。 123456789&apos;use strict&apos;;if (true) &#123; let x = &apos;hello&apos;;&#125;for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。 var命令存在变量提升效用，let命令没有这个问题。 123456&apos;use strict&apos;;if(true) &#123; console.log(x); // ReferenceError let x = &apos;hello&apos;;&#125; 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。 所以，建议不再使用var命令，而是使用let命令取代。 （2）全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提供程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。 12345678910// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。 所有的函数都应该设置为常量。 长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 1234567891011// badconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// acceptableconst c = `foobar`;// goodconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 1234567891011121314// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 1234567891011// badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 12345678910111213// badconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123; id: 5, name: &apos;San Francisco&apos;, [getKey(&apos;enabled&apos;)]: true,&#125;; 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 1234567891011121314151617181920212223var ref = &apos;some value&apos;;// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组使用扩展运算符（…）拷贝数组。 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组。 12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 函数立即执行函数可以写成箭头函数的形式。 123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。 123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。 1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。 123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。 12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。 1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 使用export取代module.exports。 123456789101112131415161718192021// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;const Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);export default Breadcrumbs 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 12345// badimport * as myObject &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。 1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。 123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide; ESLint的使用ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 首先，安装ESLint。 1$ npm i -g eslint 然后，安装Airbnb语法规则。 1$ npm i -g eslint-config-airbnb 最后，在项目的根目录下新建一个.eslintrc文件，配置ESLint。 123&#123; &quot;extends&quot;: &quot;eslint-config-airbnb&quot;&#125; 现在就可以检查，当前项目的代码是否符合预设的规则。 index.js文件的代码如下。 12345678var unusued = &apos;I have no purpose!&apos;;function greet() &#123; var message = &apos;Hello, World!&apos;; alert(message);&#125;greet(); 使用ESLint检查这个文件。 1234567$ eslint index.jsindex.js 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 5:5 error Expected indentation of 2 characters but found 4 indent✖ 3 problems (3 errors, 0 warnings) 上面代码说明，原文件有三个错误，一个是定义了变量，却没有使用，另外两个是行首缩进为4个空格，而不是规定的2个空格。","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JavaScript实现继承","slug":"js实现继承","date":"2017-02-12T08:12:11.000Z","updated":"2017-08-21T10:01:17.013Z","comments":true,"path":"2017/02/12/js实现继承/","link":"","permalink":"http://yoursite.com/2017/02/12/js实现继承/","excerpt":"","text":"JavaScript中实现继承的几种方法ES5中的实现概述JavaScript(ES5)中没有像Java那样类的概念，写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。但是我们可以通过原型链prototype来模拟类，去实现继承的相关功能。下面来看看ES5中实现继承常见的三种方法。代码如下： 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * JavaScript(ES5)中实现继承的几种方法 */// 定义基类Personfunction Person(name, age) &#123; this.name = name; this.age = age;&#125;// 共享数据Person.prototype.LEGS_NUM = 2;// 共享方法Person.prototype.info = function () &#123; console.log(&apos;My name is &apos; + this.name + &apos; .I\\&apos;m &apos; + this.age + &apos; years old now&apos;);&#125;;Person.prototype.walk = function () &#123; console.log(this.name + &apos; is walking...&apos;);&#125;;// Student子类function Student(name, age, className) &#123; // 调用父类 Person.call(this, name, age); this.className = className;&#125;// 1⃣️ 方法一：Person.prototype直接赋值给Student.prototype// Student.prototype = Person.prototype;// 2⃣️ 方法二：Student.prototype为Person的实例// Student.prototype = new Person();// 3⃣️ 方法三：创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototypeStudent.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;// 覆盖父类的info方法Student.prototype.info = function () &#123; console.log(&apos;My name is &apos; + this.name + &apos;,I\\&apos;m &apos; + this.age + &apos; years old now, and from class &apos; + this.className + &apos;.&apos;);&#125;;// Student类的共享方法Student.prototype.learn = function (subject) &#123; console.log(this.name + &apos; is learning &apos; + subject + &apos;.&apos;);&#125;;// 测试,创建一个Student的实例var microzz = new Student(&apos;Microzz&apos;, 22, 5);microzz.info(); // My name is Microzz,I&apos;m 22 years old now, and from class 5.console.log(microzz.LEGS_NUM); // 2microzz.walk(); // Microzz is walking...microzz.learn(&apos;JavaScript&apos;); // Microzz is learning JavaScript.console.log(microzz.__proto__.__proto__ === Person.prototype); // trueconsole.log(microzz.__proto__ === Student.prototype); // trueconsole.log(microzz.__proto__.constructor === Student); // true 三种方法比较上面代码中有三种方法实现继承，现在我们可以来分析一下这几种方法。1⃣️这种方法中，Person.prototype直接赋值给Student.prototype，但是有一个很严重的问题，如果子类prototype添加新的东西的话也会改写父类。所以这种方法不推荐。2⃣️第二种方法Student.prototype为Person的实例，这也是可以实现的。但是Person构造函数有参数应该传什么呢？传任何一个都是很奇怪的。所以也不推荐。3⃣️第三种方法是比较理想的，创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototype。但是Object.create也有一点小瑕疵，因为它是ES5之后才支持的，不过我们可以通过模拟实现Object.create方法。代码如下： 1234567if (!Object.create) &#123; Object.prototype.create = function (proto) &#123; function F() &#123;&#125; F.prototype = proto; return new F; &#125;&#125; 这样在ES5中就完美实现了继承😄 ES6中的实现概述ES6提供了更接近传统语言”类”的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。下面我们用ES6的语法实现类的继承。 代码123456789101112131415161718192021222324252627282930313233343536373839404142// 基类 Personclass Person &#123; // 父类的构造方法 constructor(name, age) &#123; this.name = name; this.age = age; // 共享变量 this.LEGS_NUM = 2; &#125; // 父类的info方法 info() &#123; console.log(`My name is $&#123;this.name&#125;, I\\&apos;m $&#123;this.age&#125; years old now.`); &#125; // 父类的walk方法 walk() &#123; console.log(this.name + &apos; is walking...&apos;); &#125;&#125;// 子类 Studentclass Student extends Person &#123; constructor(name, age, className) &#123; // 调用基类的构造方法 super(name, age); this.className = className; &#125; // 覆盖父类的info方法 info() &#123; console.log(`My name is $&#123;this.name&#125;, I\\&apos;m $&#123;this.age&#125; years old, and from class $&#123;this.className&#125;.`); &#125;&#125;// 实例化一个Student的实例let stu = new Student(&apos;Zhaohui&apos;, 22, 5);stu.info(); // My name is Zhaohui, I&apos;m 22 years old, and from class 5.stu.walk(); // Zhaohui is walking...console.log(stu.LEGS_NUM); // 2console.log(stu instanceof Student); // trueconsole.log(stu instanceof Person); // true 这样我们就通过ES6中的class实现了“类”的继承了😄","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript编码规范指南","slug":"js编码规范","date":"2017-02-12T08:12:11.000Z","updated":"2017-08-21T09:56:25.883Z","comments":true,"path":"2017/02/12/js编码规范/","link":"","permalink":"http://yoursite.com/2017/02/12/js编码规范/","excerpt":"","text":"JavaScript编码规范指南=====================常用的一些javascript规范 数据类型 原始类型(Primitives)：当你给一个原始类型赋值时，返回的是这个值的本身。 string number boolean null undefined 123456var foo = 1, bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 对象类型:当你给一个对象类型赋值时，返回的是这个值的引用。 object array function 123456var foo = [1, 2], bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 对象 新建一个对象的语法 12345//不推荐var item = new Object();//推荐var item = &#123;&#125;; 不要使用保留字作为键值，否则在IE8下面会出现问题(详情)。 1234567891011//不推荐var superman = &#123; default: &#123; clark: &apos;kent&apos;&#125;, private: true&#125;;//推荐var superman =&#123; defaults: &#123; clark: &apos;kent&apos;&#125;, hidden: true&#125;; 使用可读性强的同义词代替保留字 1234567891011121314//不推荐var superman = &#123; class: &apos;alien&apos;&#125;;//不推荐var superman = &#123; klass: &apos;alien&apos;&#125;;//推荐var superman = &#123; type: &apos;alien&apos;&#125;; 数组 新建一个数组的语法 12345//不推荐var items = new Array();//推荐var items = []; 如果你不知道数组的长度可以使用push将元素加入。 1234567var someStack = [];//不推荐someStack[someStack.length] = &apos;something&apos;;//推荐someStack.push(&apos;something&apos;); 当你需要复制一个数组的时候使用slice。jsPerf 1234567891011var len = items.length, itemsCopy = [], i;//不推荐for (i = 0; i &lt; len; i++)&#123; itemsCopy[i] = items[i];&#125;//推荐itemsCopy = items.slice(); 用slice转换伪数组对象到数组 1234function trigger() &#123; var args = Array.prototype.slice.call(arguments); ...&#125; String类型 使用单引号&#39;&#39; 1234567891011//不推荐var name = &quot;Bob Parr&quot;;//推荐var name = &apos;Bob Parr&apos;;//不推荐var fullName - &quot;Bob &quot; + this.lastName;//推荐var fullName = &apos;Bob &apos; + this.lastName; 当字符串长度超过80个时，应该通过字符串连接多行显示。 注意：过度使用字符串连接将会影响性能。jsPerf&amp;Discussion 123456789101112131415161718//不推荐var errorMessage = &apos;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&apos;;//不推荐var errorMessage = &apos;This is a super long error that \\was thrown because of Batman. \\When you stop to think about \\how Batman had anything to do \\with this, you would get nowhere \\fast.&apos;;//推荐var errorMessage = &apos;This is a super long error that &apos; + &apos;was thrown because of Batman.&apos; + &apos;When you stop to think about &apos; + &apos;how Batman had anything to do &apos; + &apos;with this, you would get nowhere &apos; + &apos;fast.&apos;; 当程序建立一个字符串时， 使用join代替字符串连接。特别是在IE下：jsPerf 1234567891011121314151617181920212223242526272829303132333435363738var items, messages, length, i;messages = [&#123; state: &apos;success&apos;, message: &apos;This one worked.&apos;&#125;,&#123; state: &apos;success&apos;, message: &apos;This one worked as well.&apos;&#125;,&#123; state: &apos;error&apos;, message: &apos;This one did not work.&apos;&#125;];length = messages.length;// 不推荐function inbox(messages) &#123; items = &apos;&lt;ul&gt;&apos;; for (i = 0; i &lt; length; i++) &#123; items += &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;; &#125; return items + &apos;&lt;/ul&gt;&apos;;&#125;// 推荐function inbox(messages) &#123; items = []; for (i = 0; i &lt; length; i++) &#123; items[i] = messages[i].message; &#125; return &apos;&lt;ul&gt;&lt;li&gt;&apos; + items.join(&apos;&lt;/li&gt;&lt;li&gt;&apos;) + &apos;&lt;/li&gt;&lt;/ul&gt;&apos;;&#125; 函数 函数表达式： 1234567891011121314// 匿名函数表达式var anonymous = function()&#123; return true;&#125;// 命名函数表达式var named = function named() &#123; return true;&#125;;// 立即执行的函数表达式（IIFE）(function()&#123; console.log(&apos;Welcome to the Internet. Please follow me.&apos;);&#125;)(); 不要将函数声明放在如if/while循环或其他任何语句中。但可以用函数表达式来替代函数声明这么做。一些浏览器可能的确可以在语句中使用函数声明。但是在解析方面的处理各不相同，各种浏览器下兼容性很不好。 注意: ECMA-262定义了一系列的语句，但是函数声明并没有被归类为真正的语句。关于这点可查看ECMA-262的文档 12345678910111213//不推荐if (currentUser)&#123; function test() &#123; console.log(&apos;Nope.&apos;); &#125;&#125;//推荐if (currentUser)&#123; var test = function test() &#123; console.log(&apos;Yup.&apos;); &#125;&#125; arguments 不能作为一个参数的名字， 因为这会覆盖每一个函数内的arguments对象。 123456789//不推荐function nope(name, options, arguments) &#123; // ...stuff...&#125;//推荐function yup(name, options, args) &#123; // ...stuff...&#125; 属性 访问一个属性时，使用点的形式取值。 12345678910var luke = &#123; jedi: true, age: 28&#125;;// 不推荐var isJedi = luke[&apos;jedi&apos;];// 推荐var isJedi = luke.jedi; 需要一个变量访问一个属性时，使用“[]”来取值。 12345678910var luke = &#123; jedi: true, age: 28&#125;;function getProp(prop) &#123; return luke[prop];&#125;var isJedi = getProp(&apos;jedi&apos;); 变量 总是使用 var 来定义变量。如果不这么做将定义一个全局变量出来。我们希望避免全局命名空间的污染。 12345// 不推荐superPower = new SuperPower();// 推荐var superPower = new SuperPower(); 使用一个var 声明多个变量，并且每声明一个变量就换一行。 123456789// 不推荐var items = getItems();var goSportsTeam = true;var dragonball = &apos;z&apos;;// 推荐var items = getItems(), goSportsTeam = true, dragonball = &apos;z&apos;; 声明多个变量时，把不赋值的变量放在后面。这样做是有好处的，如果日后你想给未赋值变量赋值的时候，可能要引用到上面已经赋值的变量。 1234567891011121314151617// 不推荐var i, len, dragonball, items = getItems(), goSportsTeam = true;// 不推荐var i, items = getItems(), dragonball, goSportsTeam = true, len;// 推荐var items = getItems(), goSportsTeam = true, dragonball, length, i; 在一个作用域的顶部给一个变量赋值。这样有助于避开，变量声明和声明提前的分配问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 不推荐function() &#123; test(); console.log(&apos;doing stuff..&apos;); //..other stuff.. var name = getName(); if (name === &apos;test&apos;) &#123; return false; &#125; return name;&#125;// 推荐function() &#123; var name = getName(); test(); console.log(&apos;doing stuff..&apos;); //..other stuff.. if (name === &apos;test&apos;) &#123; return false; &#125; return name;&#125;// 不推荐function() &#123; var name = getName(); if (!arguments.length) &#123; return false; &#125; return true;&#125;// 推荐function() &#123; if (!arguments.length) &#123; return false; &#125; var name = getName(); return true;&#125; 声明提前 不管你在何处给一个变量声明或赋值，javascript解析器都会事先在作用域的顶端做声明提前（Hoisting）。 12345678910111213141516171819// 我们知道下面将不能正常运行（假设没有全局变量）function example() &#123; console.log(notDefined); // =&gt; 抛出一个引用错误&#125;// 在引用这个变量之后，给这个变量赋值将不会抛异常，这是因为javascript解析器有声明提前。// 注意：赋的“true”值，不会被提前。function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// javascript解析器,会在作用域的顶部提前声明变量。// 用代码描述出来，其实就等同于下面这种情况。function example() &#123; var declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125; 匿名函数表达式将该变量名做了提前声明，没有给该变量赋值函数。 123456789function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; 抛出异常，anonymous 不是一个函数 var anonymous = function() &#123; console.log(&apos;anonymous function expression&apos;); &#125;;&#125; 和匿名一样，有名函数表达式将该变量名做了提前声明，没有给该变量赋值函数名和函数体。 12345678910111213141516171819202122function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; 抛出异常， named 不是一个函数 superPower(); // =&gt; 抛出异常， superPower 没定义 var named = function superPower() &#123; console.log(&apos;Flying&apos;); &#125;;&#125;// 把函数名改成和变量名一样，也得出同样的结果。function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; 抛出异常， named 不是一个函数 var named = function named() &#123; console.log(&apos;named&apos;); &#125;;&#125; 函数声明会将函数名和函数体声明提前。 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log(&apos;Flying&apos;); &#125;&#125; 更多信息请参照 Ben Cherry 的 JavaScript Scoping &amp; Hoisting 条件表达式与等式 使用 === 和 !== 代替 == 和 !=。 条件表达式 会通过 ToBoolean 来进行强制转化，而且遵循以下的规则： 对象被转化为true Undefined被转化为false Null被转化为false 布尔值被转化为相应的布尔值 数字当值为+0,-0或NaN时转化为false，其他的转化为true Strings类型如果为空时转化为false,否则转化为true 1234if ([0]) &#123; // true // 因为数组是对象，对象会被转化为 true&#125; 使用快捷方式 12345678910111213141516171819// 不推荐if (name !== &apos;&apos;) &#123; // ...stuff...&#125;// 推荐if (name) &#123; // ...stuff...&#125;// 不推荐if (collection.length &gt; 0) &#123; // ...stuff...&#125;// 推荐if (collection.length) &#123; // ...stuff...&#125; 更多的信息 请看 Angus Croll 的 Truth Equality and JavaScript 块 给多行的块，使用大括号 12345678910111213141516171819// 不推荐if (test) return false;// 推荐if (test) return false;// 推荐if (test) &#123; return false;&#125;// 不推荐function() &#123; return false; &#125;// 推荐function() &#123; return false;&#125; 注释 使用 /**...*/ 进行多行注释。注释要包括描述、指定类型、参数值和返回值。 12345678910111213141516171819202122232425262728// 不推荐// make() returns a new element// based on the passed in tag name//// @param &lt;String&gt; tag// @return &lt;Element&gt; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// 推荐/** * make() returns a new element * based on the passed in tag name * * @param &lt;String&gt; tag * @return &lt;Element&gt; element */function make(tag) &#123; // ...stuff... return element;&#125; 使用 // 进行单行注释。注释单独占一行，并写在需要注释对象的上面。在注释的上面留一个空行。 12345678910111213141516171819202122232425// 不推荐var active = true; // is current tab// 推荐// is current tabvar active = true;// 不推荐function getType() &#123; console.log(&apos;fetching type...&apos;); // set the default type to &apos;no type&apos; var type = this._type || &apos;no type&apos;; return type;&#125;// 推荐function getType() &#123; console.log(&apos;fetching type...&apos;); // set the default type to &apos;no type&apos; var type = this._type || &apos;no type&apos;; return type;&#125; 给你的代码加前缀，比如FIXME或TODO，这样有助于其他开发者可以迅速理解你指出的需要被处理的问题。如果想更清晰一点你还可以在后面加上描述，比如: FIXME -- need to figure this out或TODO -- need to implement. 使用 // FIXME: 去注释问题 1234567function Calculator() &#123; // FIXME: shouldn&apos;t use a global here total = 0; return this;&#125; 使用 // TODO: 来注释解决方法 1234567function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; 空格 将tab键设成2个空格 123456789101112131415// 不推荐function() &#123;∙∙∙∙var name;&#125;// 不推荐function() &#123;∙var name;&#125;// 推荐function() &#123;∙∙var name;&#125; 逗号/冒号/小括号后面留一个空格 123456789101112131415161718192021// 不推荐function test()&#123; console.log(&apos;test&apos;);&#125;// 推荐function test() &#123; console.log(&apos;test&apos;);&#125;// 不推荐dog.set(&apos;attr&apos;,&#123; age: &apos;1 year&apos;, breed: &apos;Bernese Mountain Dog&apos;&#125;);// 推荐dog.set(&apos;attr&apos;, &#123; age: &apos;1 year&apos;, breed: &apos;Bernese Mountain Dog&apos;&#125;); 在文件的最后留一个空行 1234// 不推荐(function(global) &#123; // ...stuff...&#125;)(this); 1234// 推荐(function(global) &#123; // ...stuff...&#125;)(this); 逗号 逗号不要前置 12345678910111213141516171819202122232425// 不推荐var once , upon , aTime;// 推荐var once, upon, aTime;// 不推荐var hero = &#123; firstName: &apos;Bob&apos; , lastName: &apos;Parr&apos; , heroName: &apos;Mr. Incredible&apos; , superPower: &apos;strength&apos;&#125;;// 推荐var hero = &#123; firstName: &apos;Bob&apos;, lastName: &apos;Parr&apos;, heroName: &apos;Mr. Incredible&apos;, superPower: &apos;strength&apos;&#125;; 最后一个元素不可以加逗号。这在IE6和IE7还有IE9的怪异模式下出错。 关于","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"SASS用法指南","slug":"SASS用法指南","date":"2017-02-10T03:42:31.000Z","updated":"2017-08-21T09:45:25.544Z","comments":true,"path":"2017/02/10/SASS用法指南/","link":"","permalink":"http://yoursite.com/2017/02/10/SASS用法指南/","excerpt":"","text":"SASS用法指南 学过CSS的人都知道，它不是一种编程语言。你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。很自然地，有人就开始为CSS加入编程元素，这被叫做”CSS预处理器”（css preprocessor）。它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。各种”CSS预处理器”之中，我自己最喜欢SASS，觉得它有很多优点，打算以后都用它来写CSS。下面是我整理的用法总结，供自己开发时参考，相信对其他人也有用。 什么是SASSSASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。本文总结了SASS的主要用法。我的目标是，有了这篇文章，日常的一般使用就不需要去看官方文档了。 安装和使用安装SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先安装Ruby，然后再安装SASS。假定你已经安装好了Ruby，接着在命令行输入下面的命令： gem install sass然后，就可以使用了。 使用SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。下面的命令，可以在屏幕上显示.scss文件转化的css代码。（假设文件名为test。） sass test.scss如果要将显示结果保存成文件，后面再跟一个.css文件名。 sass test.scss test.cssSASS提供四个编译风格的选项： nested：嵌套缩进的css代码，它是默认值。 expanded：没有缩进的、扩展的css代码。 compact：简洁格式的css代码。 compressed：压缩后的css代码。生产环境当中，一般使用最后一个选项。 sass –style compressed test.sass test.css你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。 // watch a file sass –watch input.scss:output.css // watch a directory sass –watch app/sass:public/stylesheets SASS的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。 基本用法变量SASS允许使用变量，所有变量以$开头。 $blue : #1875e7; div { color : $blue; } 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。 $side : left; .rounded { border-#{$side}-radius: 5px; } 计算功能SASS允许在代码中使用算式： body { margin: (14px/2); top: 50px + 100px; right: $var * 10%; } 嵌套SASS允许选择器嵌套。比如，下面的CSS代码： div h1 { color : red; }可以写成： div { hi { color:red; } }属性也可以嵌套，比如border-color属性，可以写成： p { border: { color: red; } }注意，border后面必须加上冒号。在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类，可以写成： a { &amp;:hover { color: #ffb3ff; } } 注释SASS共有两种注释风格。标准的CSS注释 / comment /，会保留到编译后的文件。单行注释 // comment，只保留在SASS源文件中，编译后被省略。在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 /! 重要注释！ / 代码的重用继承SASS允许一个选择器，继承另一个选择器。比如，现有class1： .class1 { border: 1px solid #ddd; }class2要继承class1，就要使用@extend命令： .class2 { @extend .class1; font-size:120%; } MixinMixin有点像C语言的宏（macro），是可以重用的代码块。使用@mixin命令，定义一个代码块。 @mixin left { float: left; margin-left: 10px; }使用@include命令，调用这个mixin。 div { @include left; }mixin的强大之处，在于可以指定参数和缺省值。 @mixin left($value: 10px) { float: left; margin-right: $value; }使用的时候，根据需要加入参数： div { @include left(20px); }下面是一个mixin的实例，用来生成浏览器前缀。 @mixin rounded($vert, $horz, $radius: 10px) { border-#{$vert}-#{$horz}-radius: $radius; -moz-border-radius-#{$vert}#{$horz}: $radius; -webkit-border-#{$vert}-#{$horz}-radius: $radius; }使用的时候，可以像下面这样调用： #navbar li { @include rounded(top, left); } #footer { @include rounded(top, left, 5px); } 颜色函数SASS提供了一些内置的颜色函数，以便生成系列颜色。 lighten(#cc3, 10%) // #d6d65c darken(#cc3, 10%) // #a3a329 grayscale(#cc3) // #808080 complement(#cc3) // #33c 插入文件@import命令，用来插入外部文件。 @import “path/filename.scss”;如果插入的是.css文件，则等同于css的import命令。 @import “foo.css”; 高级用法条件语句@if可以用来判断： p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 &lt; 3 { border: 2px dotted; } }配套的还有@else命令： @if lightness($color) &gt; 30% { background-color: #000; } @else { background-color: #fff; } 循环语句SASS支持for循环： @for $i from 1 to 10 { .border-#{$i} { border: #{$i}px solid blue; } }也支持while循环： $i: 6; @while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; }each命令，作用与for类似： @each $member in a, b, c, d { .#{$member} { background-image: url(“/image/#{$member}.jpg”); } } 自定义函数SASS允许用户编写自己的函数。 @function double($n) { @return $n * 2; } #sidebar { width: double(5px); }","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"sass","slug":"sass","permalink":"http://yoursite.com/tags/sass/"}]},{"title":"浏览器兼容性问题","slug":"浏览器兼容性问题","date":"2016-12-18T11:12:11.000Z","updated":"2017-09-01T03:33:57.362Z","comments":true,"path":"2016/12/18/浏览器兼容性问题/","link":"","permalink":"http://yoursite.com/2016/12/18/浏览器兼容性问题/","excerpt":"","text":"浏览器兼容性问题 所谓的浏览器兼容性问题，是指因为不同的浏览器对同一段代码有不同的解析，造成页面显示效果不统一的情况。在大多数情况下，我们的需求是，无论用户用什么浏览器来查看我们的网站或者登陆我们的系统，都应该是统一的显示效果。所以浏览器的兼容性问题是[前端开发]人员经常会碰到和必须要解决的问题。 在学习浏览器兼容性之前，我想把前端开发人员划分为两类： 第一类是精确按照设计图开发的前端开发人员，可以说是精确到1px的，他们很容易就会发现设计图的不足，并且在很少的情况下会碰到浏览器的兼容性问题，而这些问题往往都死浏览器的bug，并且他们制作的页面后期易维护，代码重用问题少，可以说是比较牢固放心的代码。 第二类是基本按照设计图来开发的前端开发人员，很多细枝末节差距很大，不如间距，行高，图片位置等等经常会差几px。某种效果的实现也是反复调试得到，具体为什么出现这种效果还模模糊糊，整体布局十分脆弱。稍有改动就乱七八糟。代码为什么这么写还不知所以然。这类开发人员往往经常为兼容性问题所困。修改好了这个浏览器又乱了另一个浏览器。改来改去也毫无头绪。其实他们碰到的兼容性问题大部分不应该归咎于浏览器，而是他们的技术本身了。 文章主要针对的是第一类，严谨型的开发人员，因此这里主要从浏览器解析差异的角度来分析兼容性问题。（相关文章推荐：主流浏览器CSS 3和HTML 5兼容查询 问题一：不同浏览器的标签默认的外补丁和内补丁不同问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。 碰到频率:100% 解决方案：CSS里 *{margin:0;padding:0;} 备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。 问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大问题症状:常见症状是IE6中后面的一块被顶到下一行 碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题） 解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性 备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。 问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度 碰到频率：60% 解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。 备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。 问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug问题症状：IE6里的间距比超过设置的间距 碰到几率：20% 解决方案：在display:block;后面加入display:inline;display:table; 备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。 问题五：图片默认有间距问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。 碰到几率：20% 解决方案：使用float属性为img布局 备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用） 问题六：标签最低高度设置min-height不兼容问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容 碰到几率：5% 解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;} 备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。 问题七：透明度的兼容CSS设置做兼容页面的方法是：每写一小段代码（布局中的一行或者一块）我们都要在不同的浏览器中看是否兼容，当然熟练到一定的程度就没这么麻烦了。建议经常会碰到兼容性问题的新手使用。很多兼容性问题都是因为浏览器对标签的默认属性解析不同造成的，只要我们稍加设置都能轻松地解决这些兼容问题。如果我们熟悉标签的默认属性的话，就能很好的理解为什么会出现兼容问题以及怎么去解决这些兼容问题。 1. /* CSS hack*/ 我很少使用hacker的，可能是个人习惯吧，我不喜欢写的代码IE不兼容，然后用hack来解决。不过hacker还是非常好用的。使用hacker我可以把浏览器分为3类：IE6 ；IE7和遨游；其他（IE8 chrome ff safari opera等） ◆IE6认识的hacker 是下划线_ 和星号 * ◆IE7 遨游认识的hacker是星号 * 比如这样一个CSS设置： 1. height:300px;*height:200px;_height:100px; IE6浏览器在读到height:300px的时候会认为高时300px；继续往下读，他也认识heihgt， 所以当IE6读到height:200px的时候会覆盖掉前一条的相冲突设置，认为高度是200px。继续往下读，IE6还认识_height,所以他又会覆盖掉200px高的设置，把高度设置为100px； IE7和遨游也是一样的从高度300px的设置往下读。当它们读到*height200px的时候就停下了，因为它们不认识_height。所以它们会把高度解析为200px，剩下的浏览器只认识第一个height:300px;所以他们会把高度解析为300px。因为优先级相同且想冲突的属性设置后一个会覆盖掉前一个，所以书写的次序是很重要的。","categories":[],"tags":[{"name":"编码","slug":"编码","permalink":"http://yoursite.com/tags/编码/"}]},{"title":"vim入坑指南","slug":"vim入坑指南","date":"2016-12-14T02:04:38.000Z","updated":"2017-08-16T05:03:38.027Z","comments":true,"path":"2016/12/14/vim入坑指南/","link":"","permalink":"http://yoursite.com/2016/12/14/vim入坑指南/","excerpt":"","text":"vim入坑指南什么是VIMVim是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和Emacs并列成为类Unix系统用户最喜欢的文本编辑器。 vim的设计理念命令组合:Vim强大的编辑能力中很大部分是来自于其普通模式命令。vim的设计理念是命令的组合。例如普通模式命令”dd”删除当前行，”dj”代表删除到下一行,原理是第一个”d”含义是删除,”j”键代表移动到下一行,组合后”dj”删除当前行和下一行。另外还可以指定命令重复次数，”2dd”（重复”dd”两次），和”dj”的效果是一样的。”d^”,”^”代表行首,故组合后含义是删除到光标开始到行首间的内容(不包含光标);”d$” $”代表行尾,删除到行尾的内容(包含光标);用户学习了各种各样的文本间移动/跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。 模式间的组合:在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按”a”（append/追加）键或者”i”（insert/插入）键。 Vim三种模式插入模式：即 insert 模式，用来输入文本；编辑模式：用以执行命令，也称为正常模式，也是进入Vim的缺省模式；命令模式：用来执行冒号命令。进入Vim后会直接进入编辑模式，接下来按下i进入插入模式，可以输入字符，按下键将从插入模式转换到编辑模式，该模式用于移动和操纵文本。在编辑模式下输入:即可进入命令模式，可以进行保存、查找、替换、配置Vim操作等。 按键功能在Vim的编辑模式下，一些常用的按键都变成了功能键，并且与大家在Windows下常用的快捷键完全不同，在这里，总结一些初学Vim所用的按键功能： 按键 功能 h或← 光标左移 l或→ 光标右移 k或↑ 光标上移 j或↓ 光标下移 gg 快速定位到文本开头 G（shift+g） 快速定位到文本最后一段 0或home 快速定位到当前段首 $或end 快速定位到当前段首 Ctrl+f 向下翻一页 Ctrl+b 向上翻一页 Ctrl+d 向下翻半页 Ctrl+u 向上翻一页 /string 查找文本中光标位置下方的string字符串，如要查找kabc则直接输入/kabc即可 ?string 查找文本中光标位置上方的string字符串，如要查找kabc则直接输入?kabc即可 yy 复制光标所在的段落 y0 复制光标位置到段首的所有字符 y$ 复制光标位置到段尾的所有字符 nyy 从光标位置向下复制n段，包含光标所在的段落 ygg 复制光标位置所在段落到文本开头的所有内容 yG 复制光标位置所在段落到文本结尾的所有内容 p 将复制的内容粘贴为光标所在段落的下一段 P 将复制的内容粘贴为光标所在段落的上一段 dd 删除光标所在的段落 d0 删除光标位置到段首的所有字符 d$ 删除光标位置到段尾的所有字符 dgg 删除光标位置所在段落到文本开头的所有内容 dG 删除光标位置所在段落到文本结尾的所有内容 ndd 从光标位置向下删除n段，包含光标所在的段落 u 撤销上一个操作 Ctrl+r 重复上一个操作 :w 保存数据 :w! 保存时强制写入数据，不管文件是否为只读文件 :q 关闭Vim :q! 关闭Vim，对所做的修改不做保存 :wq 保存数据后关闭Vim :wq! 强制保存数据并关闭Vim","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"git操作详解","slug":"git操作详解","date":"2016-12-10T11:42:31.000Z","updated":"2017-08-21T09:31:50.031Z","comments":true,"path":"2016/12/10/git操作详解/","link":"","permalink":"http://yoursite.com/2016/12/10/git操作详解/","excerpt":"","text":"Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。git clone、git remote、git fetch、git pull、git push 本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。 git clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 $ git clone &lt;版本库的网址&gt; 比如，克隆jQuery的版本库。 $ git clone https://github.com/jquery/jquery.git 该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。 $ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。 $ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git$ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/SSH协议还有另一种写法。 $ git clone [user@]example.com:path/to/repo.git/通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。 git remote为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。不带选项的时候，git remote命令列出所有远程主机。 $ git remoteorigin使用-v选项，可以参看远程主机的网址。 $ git remote -vorigin git@github.com:jquery/jquery.git (fetch)origin git@github.com:jquery/jquery.git (push)上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。 $ git clone -o jQuery https://github.com/jquery/jquery.git$ git remotejQuery上面命令表示，克隆的时候，指定远程主机叫做jQuery。git remote show命令加上主机名，可以查看该主机的详细信息。 $ git remote show &lt;主机名&gt;git remote add命令用于添加远程主机。 $ git remote add &lt;主机名&gt; &lt;网址&gt;git remote rm命令用于删除远程主机。 $ git remote rm &lt;主机名&gt;git remote rename命令用于远程主机的改名。 $ git remote rename &lt;原主机名&gt; &lt;新主机名&gt; git fetch一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。 $ git fetch &lt;远程主机名&gt;上面命令将某个远程主机的更新，全部取回本地。git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 $ git fetch &lt;远程主机名&gt; &lt;分支名&gt;比如，取回origin主机的master分支。 $ git fetch origin master所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。 $ git branch -rorigin/master $ git branch -a masterremotes/origin/master上面命令表示，本地主机的当前分支是master，远程分支是origin/master。取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 $ git checkout -b newBrach origin/master上面命令表示，在origin/master的基础上，创建一个新分支。此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。 $ git merge origin/master或者$ git rebase origin/master上面命令表示在当前分支上，合并origin/master。 git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 $ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 $ git pull origin next:master如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 $ git pull origin next上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 $ git fetch origin$ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。Git也允许手动建立追踪关系。 git branch –set-upstream master origin/next上面命令指定master分支追踪origin/next分支。如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 $ git pull origin上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以省略。 $ git pull上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用rebase模式，可以使用–rebase选项。 $ git pull –rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 $ git pull -p等同于下面的命令$ git fetch –prune origin$ git fetch -p git pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。 $ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 $ git push origin master上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 $ git push origin :master等同于$ git push origin –delete master上面命令表示删除origin主机的master分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 $ git push origin上面命令表示，将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。 $ git push如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 $ git push -u origin master上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 $ git config –global push.default matching或者$ git config –global push.default simple还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。 $ git push –all origin上面命令表示，将所有本地分支都推送到origin主机。如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。 $ git push –force origin上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。最后，git push不会推送标签（tag），除非使用–tags选项。$ git push origin –tags","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"Set数据结构-ES6学习笔记","slug":"set数据结构","date":"2016-12-06T11:22:15.000Z","updated":"2017-09-06T03:13:09.578Z","comments":true,"path":"2016/12/06/set数据结构/","link":"","permalink":"http://yoursite.com/2016/12/06/set数据结构/","excerpt":"","text":"Set数据结构Set基本用法 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值 在 Set 内部，两个NaN是相等,两个对象总是不相等的。 数组去重:1234function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) Set 实例的属性和方法属性： Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 操作方法： add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false Array.from方法可以将 Set 结构转为数组12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 遍历方法 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 12345678910111213141516171819202122let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;] 12345let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let x of set) &#123; console.log(x);&#125; 12let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) ) Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; 参考资料：ES6入门-阮一峰 http://es6.ruanyifeng.com/","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"let和const命令-ES6学习笔记","slug":"let与const命令-ES6学习笔记","date":"2016-12-02T11:32:15.000Z","updated":"2017-09-06T03:14:04.828Z","comments":true,"path":"2016/12/02/let与const命令-ES6学习笔记/","link":"","permalink":"http://yoursite.com/2016/12/02/let与const命令-ES6学习笔记/","excerpt":"","text":"let和const命令 let命令只作用于代码块内 let命令必须先声明，后使用。所以，不存在变量提升。 在未声明之前，变量是不可用的。所以，typeof不再是一个百分之百安全的操作 1234567891011if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; let不允许在相同作用域内，重复声明同一个变量。因此，不能在函数内部重新声明参数 ES5 只有全局作用域和函数作用域,let为ES6带来了块级作用域 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错 do 表达式12345// 变量x会得到整个块级作用域的返回值let x = do &#123; let t = f(); t * t + 1;&#125;; const 命令 const声明一个只读的常量。一旦声明，常量的值就不能改变 const一旦声明变量，就必须立即初始化，不能留到以后赋值 const的作用域与let命令相同：只在声明所在的块级作用域内有效 const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了 ES6 声明变量的六种方法 var function let const import class 顶层对象的属性 ES5之中，顶层对象的属性与全局变量是等价的。 从ES6开始,let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性 参考资料：ES6入门-阮一峰 http://es6.ruanyifeng.com/","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"es5","slug":"es5","permalink":"http://yoursite.com/tags/es5/"}]},{"title":"变量的解构赋值-ES6学习笔记","slug":"变量的解构赋值","date":"2016-12-02T11:32:15.000Z","updated":"2017-09-04T11:34:26.258Z","comments":true,"path":"2016/12/02/变量的解构赋值/","link":"","permalink":"http://yoursite.com/2016/12/02/变量的解构赋值/","excerpt":"","text":"变量的解构赋值数组的解构赋值 如果解构不成功，变量的值就等于undefined 123456789let [a, b, c] = [1, 2, 3];let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // [] 解构赋值允许指定默认值 12let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 对象的解构赋值 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // undefined 字符串的解构赋值 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 数值和布尔值的解构赋值 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 解构赋值的用途交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据解构赋值对提取JSON对象中的数据，尤其有用。12345678910let jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 上面代码可以快速提取 JSON 数据的值。 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 遍历Map结构任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。12345678910var map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;); 参考资料：ES6入门-阮一峰 http://es6.ruanyifeng.com/","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"},{"name":"es5","slug":"es5","permalink":"http://yoursite.com/tags/es5/"}]},{"title":"markdown学习笔记","slug":"markdown学习笔记","date":"2016-10-22T06:56:10.000Z","updated":"2017-08-16T05:39:37.523Z","comments":true,"path":"2016/10/22/markdown学习笔记/","link":"","permalink":"http://yoursite.com/2016/10/22/markdown学习笔记/","excerpt":"","text":"简介Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 用途Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。 Markdown 官方文档 创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 Markdown 语法标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 #一级标题 ##二级标题 ###三级标题 一级标题 二级标题 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。只需要在文本前加入 &gt; 这种尖括号（大于号）即可 例如这样 例如这样 图片与链接插入链接与插入图片的语法很像，区别在一个 !号 图片为：{ImgCap}{/ImgCap} 链接为： 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。 例如： 这里是粗体 这里是斜体 表格 效果 语法 Blod text Emphasize text Strike-through text Link title Inline Code code Image alt List * item Blockquote &gt; quote 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。 分割线分割线的语法只需要三个 * 号。 markdown api饥人谷markdwon api:http://api.jirengu.com/#markdown","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"指南","slug":"指南","permalink":"http://yoursite.com/tags/指南/"}]},{"title":"HTML5音频可视化","slug":"HTML5音频可视化","date":"2015-12-19T13:12:55.000Z","updated":"2017-08-16T07:47:22.370Z","comments":true,"path":"2015/12/19/HTML5音频可视化/","link":"","permalink":"http://yoursite.com/2015/12/19/HTML5音频可视化/","excerpt":"","text":"HTML5音频可视化2015年过的可是真快，眼睛一闭一睁，一睁一闭…… 突然发现这一年自己完成了从一个（只会写写黑窗口程序，刷刷acm题目）的菜鸟级程序猿到前端初级攻城狮的升级。就像是经过了累年的蹲马步，站木桩式的修行，终于突破了基本功修炼瓶颈，进入到了一个新的武学世界。开始可以玩玩更加酷炫的东西了…… 话说回来，想当初在读高中的时候，看到天天动听，realplayer做出来的音频可视化效果非常的酷炫，也很想知道这种效果怎么做出来的。而正好，这学期的计算机图形学课程设计里正好有这个选题的研究，于是我果断的跳进了这个坑。 话不多说，先上预览地址效果图：HTML5 web audio 选择本地音乐文件 播放效果 实现思路与程序运行流程1.初始化canvas2.显示音频文件选取对话框3.选择要播放的音乐文件，解码音乐文件，4.将解码后的数据通过audioContext对象进行处理得到analyser5.将解析后的analyser数据逐帧显示在canvas画布上，从而获得音乐的逐帧动画。选题所用到的知识点 HTML5 CANVAS绘图操作 HTML5 AUDIO API 文件读取及浏览器同源策略与FileReader 逐帧动画原理requestAnimationFrame 浏览器事件响应 主要代码‘’’javascript window.onload = function () { var HEIGHT = window.innerHeight, WIDTH = window.innerWidth; var canvas = document.getElementById(“canvas”), audioInput = document.getElementById(‘uploadedFile’); var ctx = canvas.getContext(“2d”); var mfile, mfileName; var audioContext = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)(); window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame; function initCanvas() { canvas.height = HEIGHT; canvas.width = WIDTH; canvas.style.backgroundColor = &quot;#fff&quot;; } function loadPanel() { document.getElementById(&quot;panel&quot;).style.top = &quot;150px&quot;; } function outPanel() { document.getElementById(&quot;panel&quot;).style.top = &quot;-150px&quot;; } audioInput.onchange = function () { //这里判断一下文件长度可以确定用户是否真的选择了文件，如果点了取消则文件长度为0 if (audioInput.files.length !== 0) { mfile = audioInput.files[0]; //将文件赋值到Visualizer对象的属性上 mfileName = mfile.name; document.getElementById(&quot;title&quot;).innerHTML = &quot;解码中……*_*&quot;; start(); //获取到文件后，开始程序，这个方法会在后面定义并实现 }; } function start() { var fr = new FileReader(); fr.onload = function (e) { //文件读取完后调用此函数 var fileResult = e.target.result; //这是读取成功得到的结果ArrayBuffer数据 audioContext.decodeAudioData(fileResult, function (buffer) { //解码成功则调用此函数，参数buffer为解码后得到的结果 var audioBufferSouceNode = audioContext.createBufferSource(); var analyser = audioContext.createAnalyser(); audioBufferSouceNode.connect(analyser); analyser.connect(audioContext.destination); audioBufferSouceNode.buffer = buffer; audioBufferSouceNode.start(0); draw(analyser); outPanel(); }, function (e) { document.getElementById(&quot;title&quot;).innerHTML = &quot;文件解码失败:(&quot;; }); }; //将上一步获取的文件传递给FileReader从而将其读取为ArrayBuffer格式 fr.readAsArrayBuffer(mfile); } function draw(analyser) { var cNum = 128; analyser.fftSize = cNum * 2; var Dots = []; function random(m, n) { return Math.round(Math.random() * (n - m) + m); } function getDots() { Dots = []; for (var i = 0; i &lt; cNum; i++) { var x = random(0, canvas.width); var y = random(0, canvas.height); var color = &quot;rgba(&quot; + random(0, 255) + &quot;,&quot; + random(0, 255) + &quot;,&quot; + random(0, 255) + &quot;,&quot; + random(0,10)/10 + &quot;)&quot;; Dots.push({ x: x, y: y, dy: random(0, 2), color: color }); } } getDots(); var drawCircle = function () { var array = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(array); ctx.clearRect(0, 0, WIDTH, HEIGHT); for (var i = 0; i &lt; cNum; i++) { ctx.beginPath(); var o = Dots[i]; var r = array[i] / 256 * 30; if (o.x &gt; canvas.width||o.y&gt;canvas.height) { o.y = 0; } else { o.y = o.y; } ctx.arc(o.x, o.y, r, 0, Math.PI * 2, true); var g = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, r); g.addColorStop(0, &quot;#fff&quot;); g.addColorStop(0.9, &quot;#fff&quot;); g.addColorStop(1, o.color); //g.addColorStop(1, &quot;rgb(114,208,156)&quot;); ctx.fillStyle = g; ctx.fill(); ctx.closePath(); } requestAnimationFrame(drawCircle); } requestAnimationFrame(drawCircle); } initCanvas(); loadPanel(); }‘’’ 参考资料1.File reader in JavaScript2.Audio context from MDN3.Window.requestAnimationFrame4.开大你的音响，感受HTML5 Audio API带来的视听盛宴","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"web audio","slug":"web-audio","permalink":"http://yoursite.com/tags/web-audio/"},{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"纯css实现扁平化360卫士logo","slug":"纯css实现扁平化360卫士logo","date":"2015-12-10T08:42:51.000Z","updated":"2017-08-16T05:50:51.831Z","comments":true,"path":"2015/12/10/纯css实现扁平化360卫士logo/","link":"","permalink":"http://yoursite.com/2015/12/10/纯css实现扁平化360卫士logo/","excerpt":"","text":"纯css实现扁平化360卫士logo前几天在w3ctech上看到有人用纯css写出了360卫士的logo，感觉蛮好玩的。 因为自己用css以来，还没有写过这种玩意，出于娱乐，我也来试着尝试一下。 开始也不知到怎么下手，最棘手的是那两个像太极的东东不好弄。不过，好在以前用过photoshop绘制过一些简单的icon。所以，经过我仔细 的分析。大概有了思路，这两个东东是可以利用box-shadow这个属性来实现。虽然跟photoshop绘制有点不同，但是大致还是差不多的。 代码效果预览地址：http://code.w3ctech.com/detail/2501 对于刚在学习css的同学是个不错的小案例，分享给你们，有兴趣的可以试试。当然，如果有更好的思路的，可以在下面留言，相互探讨，一起进步。","categories":[],"tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"我喜欢出发","slug":"我喜欢出发","date":"2014-08-17T11:54:13.000Z","updated":"2017-08-16T03:58:13.791Z","comments":true,"path":"2014/08/17/我喜欢出发/","link":"","permalink":"http://yoursite.com/2014/08/17/我喜欢出发/","excerpt":"","text":"我喜欢出发——汪国真我喜欢出发。 凡是到达了的地方，都属于昨天。哪怕那山再青，那水再秀，那风再温柔。太深的流连便成了一种羁绊，绊住的不仅有双脚，还有未来。 怎么能不喜欢出发呢?没见过大山的巍峨，真是遗憾；见了大山的巍峨没见过大海的浩瀚仍然遗憾；见了大海的浩瀚没见过大漠的广袤，依旧遗憾；见了大漠的广袤没见过森林的神秘，还是遗憾。世界上有不绝的风景，我有不老的心情。 我自然知道，大山有坎坷，大海有浪涛，大漠有风沙，森林有猛兽。即便这样，我依然喜欢。 打破生活的平静便是另一番景致，一种属于年轻的景致。真庆幸，我还没有老。即便真老了又怎么样，不是有句话叫老当益壮吗? 于是，我还想从大山那里学习深刻，我还想从大海那里学习勇敢，我还想从大漠那里学习沉着，我还想从森林那里学习机敏。我想学着品味一种缤纷的人生。 人能走多远?这话不是要问两脚而是要问志向；人能攀多高?这事不是要问双手而是要问意志。于是，我想用青春的热血给自己树起一个高远的目标。不仅是为了争取一种光荣，更是为了追求一种境界。目标实现了，便是光荣；目标实现不了，人生也会因这一路风雨跋涉变得丰富而充实；在我看来，这就是不虚此生。 是的，我喜欢出发，愿你也喜欢。 每次看完这篇文章，心情都会舒畅很多，很多的不快和忧愁便会如烟散去。 想到自己还有那么多的事情没有去做，没有去尝试，就觉得自己应该坚强起来，坚持，勇敢的去一步一步的朝目标前进。虽然不知道前方等待我的是什么，但正如作者所说:”只要热爱生命，一切都在意料之中“。 是的，我也喜欢出发，喜欢去探索新的生活。","categories":[],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"}]}]}