{"meta":{"title":"我一路向北","subtitle":null,"description":null,"author":"我一路向北","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-08-16T01:47:07.000Z","updated":"2017-08-16T01:47:46.547Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-08-16T01:48:13.000Z","updated":"2017-08-16T01:48:28.924Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"你真的知道JavaScript吗","slug":"你真的了解JS吗？","date":"2017-02-18T11:12:11.000Z","updated":"2017-08-21T10:10:28.601Z","comments":true,"path":"2017/02/18/你真的了解JS吗？/","link":"","permalink":"http://yoursite.com/2017/02/18/你真的了解JS吗？/","excerpt":"","text":"你真的知道JavaScript吗 JavaScript是一门奇怪的语言，要真正掌握并不容易。废话不多说，来一个快速测试，5道题目，看看你对JavaScript是否真正掌握。准备好了吗？开始咯😄 题目No.112345if (!(&quot;a&quot; in window)) &#123; var a = 1;&#125;console.log(a); No.212345var a = 1, b = function a(x) &#123; x &amp;&amp; a(--x); &#125;;console.log(a); No.312345function a(x) &#123; return x * 2;&#125;var a;console.log(a); No.412345function b(x, y, a) &#123; arguments[2] = 10; console.log(a);&#125;b(1, 2, 3); No.51234function a() &#123; console.log(this);&#125;a.call(null); 解析No.1在浏览器环境中，全局变量都是`window`的一个属性，即 var a = 1 等价于 window.a = 1。in操作符用来判断某个属性属于某个对象，可以是对象的直接属性，也可以是通过prototype继承的属性。 再看题目，在浏览器中，如果没有全局变量 a ，则声明一个全局变量 a (ES5没有块级作用域)，并且赋值为1。很多人会认为打印的是1。非也，大家不要忘了变量声明会被前置！什么意思呢？题目也就等价于 1234567var a;if (!(&quot;a&quot; in window)) &#123; a = 1;&#125;console.log(a); 所以其实已经声明了变量a，只不过if语句之前值是undefined，所以if语句压根不会执行。最后答案就是 undefined No.2这道题有几个需要注意的地方： 变量声明、函数声明会被前置，但是函数表达式并不会，准确说类似变量声明前置，举个栗子： 123console.log(&apos;b&apos;, b); // b undefinedvar b = function() &#123;&#125;console.log(&apos;b&apos;, b); // b function () &#123;&#125; 2.具名的函数表达式的名字只能在该函数内部取到，举个例子(排除老的IE😂)： 1234567var foo = function bar () &#123;&#125;console.log(&apos;foo&apos;, foo); // foo function bar()&#123;&#125;console.log(&apos;bar&apos;, bar);// Uncaught ReferenceError: bar is not defined 综合这两点，再看题目，最后输出的内容就为 1 No.3函数声明会覆盖变量声明，但不会覆盖变量赋值，举个栗子简单粗暴： 12345function foo()&#123; return 1;&#125;var foo;console.log(typeof foo); // &quot;function&quot; 函数声明的优先级高于变量声明的优先级，但如果该变量foo赋值了，那结果就完全不一样了： 12345function foo()&#123; return 1;&#125;var foo = 1;console.log(typeof foo); // &quot;number&quot; 变量foo赋值以后，变量赋值初始化就覆盖了函数声明。这个需要注意再看题目 12345function a(x) &#123; return x * 2;&#125;var a;console.log(a); // function a(x) &#123;...&#125; No.4这题考察 arguments 对象的用法(详看👉JavaScript中的arguments对象)一般情况，arguments与函数参数是动态绑定关系(为什么说是一般稍后会解释)，所以很好理解，最后输出的是10 但是但是但是，我们不要忘了一个特殊情况–严格模式，在严格模式中 arguments 与相当于函数参数的一个拷贝，并没有动态绑定关系，举个栗子： 12345678&apos;use strict&apos;// 严格模式！！function b(x, y, a) &#123; arguments[2] = 10; console.log(a);&#125;b(1, 2, 3); // 3 No.51234function a() &#123; console.log(this);&#125;a.call(null); 关于 a.call(null); 根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined的话，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管你什么时候传入null或者 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。 但是但是但是，我们依旧不能忘记一个特殊情况–严格模式，在严格模式中，null 就是 null，undefined 就是 undefined ，举个栗子： 12345678&apos;use strict&apos;;// 严格模式！！function a() &#123; console.log(this);&#125;a.call(null); // nulla.call(undefined); // undefined 提醒 在浏览器中的全局对象是window，Node.js中是global; 为了使代码更加严谨与健壮，建议写JS都加上严格模式&#39;use strict&#39;; ES6已经成为前端必备技能，呼吁大家都使用ES6，方便高效，可以使用babel把ES6转成ES5甚至ES3，尽量使用ES6推动前端的发展👍","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"原生JS中CSS相关API合集","slug":"原生JS中CSS相关API合集","date":"2017-02-14T07:12:11.000Z","updated":"2017-08-21T10:06:25.691Z","comments":true,"path":"2017/02/14/原生JS中CSS相关API合集/","link":"","permalink":"http://yoursite.com/2017/02/14/原生JS中CSS相关API合集/","excerpt":"","text":"原生JS中CSS相关API合集类名操作12345678910111213141516171819//ie8以下Element.className //获取元素节点的类名Element.className += &apos; &apos; + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className)&#123; return new RegExp(className,&apos;gi&apos;).test(element.className);&#125;//移除classfunction removeClass(element,className)&#123; element.className = element.className.replace(new RegExp(&apos;(^|\\\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\\\b|$)&apos;, &apos;gi&apos;),&apos;&apos;);&#125;//ie10 element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class style操作1234567891011121314151617element.setAttribute(&apos;style&apos;,&apos;&apos;)element.style.backgroundColor = &apos;red&apos;element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,&apos;:after&apos;)[attrName]","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"JavaScript实现继承","slug":"js实现继承","date":"2017-02-12T08:12:11.000Z","updated":"2017-08-21T10:01:17.013Z","comments":true,"path":"2017/02/12/js实现继承/","link":"","permalink":"http://yoursite.com/2017/02/12/js实现继承/","excerpt":"","text":"JavaScript中实现继承的几种方法ES5中的实现概述JavaScript(ES5)中没有像Java那样类的概念，写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。但是我们可以通过原型链prototype来模拟类，去实现继承的相关功能。下面来看看ES5中实现继承常见的三种方法。代码如下： 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * JavaScript(ES5)中实现继承的几种方法 */// 定义基类Personfunction Person(name, age) &#123; this.name = name; this.age = age;&#125;// 共享数据Person.prototype.LEGS_NUM = 2;// 共享方法Person.prototype.info = function () &#123; console.log(&apos;My name is &apos; + this.name + &apos; .I\\&apos;m &apos; + this.age + &apos; years old now&apos;);&#125;;Person.prototype.walk = function () &#123; console.log(this.name + &apos; is walking...&apos;);&#125;;// Student子类function Student(name, age, className) &#123; // 调用父类 Person.call(this, name, age); this.className = className;&#125;// 1⃣️ 方法一：Person.prototype直接赋值给Student.prototype// Student.prototype = Person.prototype;// 2⃣️ 方法二：Student.prototype为Person的实例// Student.prototype = new Person();// 3⃣️ 方法三：创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototypeStudent.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;// 覆盖父类的info方法Student.prototype.info = function () &#123; console.log(&apos;My name is &apos; + this.name + &apos;,I\\&apos;m &apos; + this.age + &apos; years old now, and from class &apos; + this.className + &apos;.&apos;);&#125;;// Student类的共享方法Student.prototype.learn = function (subject) &#123; console.log(this.name + &apos; is learning &apos; + subject + &apos;.&apos;);&#125;;// 测试,创建一个Student的实例var microzz = new Student(&apos;Microzz&apos;, 22, 5);microzz.info(); // My name is Microzz,I&apos;m 22 years old now, and from class 5.console.log(microzz.LEGS_NUM); // 2microzz.walk(); // Microzz is walking...microzz.learn(&apos;JavaScript&apos;); // Microzz is learning JavaScript.console.log(microzz.__proto__.__proto__ === Person.prototype); // trueconsole.log(microzz.__proto__ === Student.prototype); // trueconsole.log(microzz.__proto__.constructor === Student); // true 三种方法比较上面代码中有三种方法实现继承，现在我们可以来分析一下这几种方法。1⃣️这种方法中，Person.prototype直接赋值给Student.prototype，但是有一个很严重的问题，如果子类prototype添加新的东西的话也会改写父类。所以这种方法不推荐。2⃣️第二种方法Student.prototype为Person的实例，这也是可以实现的。但是Person构造函数有参数应该传什么呢？传任何一个都是很奇怪的。所以也不推荐。3⃣️第三种方法是比较理想的，创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototype。但是Object.create也有一点小瑕疵，因为它是ES5之后才支持的，不过我们可以通过模拟实现Object.create方法。代码如下： 1234567if (!Object.create) &#123; Object.prototype.create = function (proto) &#123; function F() &#123;&#125; F.prototype = proto; return new F; &#125;&#125; 这样在ES5中就完美实现了继承😄 ES6中的实现概述ES6提供了更接近传统语言”类”的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。下面我们用ES6的语法实现类的继承。 代码123456789101112131415161718192021222324252627282930313233343536373839404142// 基类 Personclass Person &#123; // 父类的构造方法 constructor(name, age) &#123; this.name = name; this.age = age; // 共享变量 this.LEGS_NUM = 2; &#125; // 父类的info方法 info() &#123; console.log(`My name is $&#123;this.name&#125;, I\\&apos;m $&#123;this.age&#125; years old now.`); &#125; // 父类的walk方法 walk() &#123; console.log(this.name + &apos; is walking...&apos;); &#125;&#125;// 子类 Studentclass Student extends Person &#123; constructor(name, age, className) &#123; // 调用基类的构造方法 super(name, age); this.className = className; &#125; // 覆盖父类的info方法 info() &#123; console.log(`My name is $&#123;this.name&#125;, I\\&apos;m $&#123;this.age&#125; years old, and from class $&#123;this.className&#125;.`); &#125;&#125;// 实例化一个Student的实例let stu = new Student(&apos;Zhaohui&apos;, 22, 5);stu.info(); // My name is Zhaohui, I&apos;m 22 years old, and from class 5.stu.walk(); // Zhaohui is walking...console.log(stu.LEGS_NUM); // 2console.log(stu instanceof Student); // trueconsole.log(stu instanceof Person); // true 这样我们就通过ES6中的class实现了“类”的继承了😄","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript编码规范指南","slug":"js编码规范","date":"2017-02-12T08:12:11.000Z","updated":"2017-08-21T09:56:25.883Z","comments":true,"path":"2017/02/12/js编码规范/","link":"","permalink":"http://yoursite.com/2017/02/12/js编码规范/","excerpt":"","text":"JavaScript编码规范指南=====================常用的一些javascript规范 数据类型 原始类型(Primitives)：当你给一个原始类型赋值时，返回的是这个值的本身。 string number boolean null undefined 123456var foo = 1, bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 对象类型:当你给一个对象类型赋值时，返回的是这个值的引用。 object array function 123456var foo = [1, 2], bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 对象 新建一个对象的语法 12345//不推荐var item = new Object();//推荐var item = &#123;&#125;; 不要使用保留字作为键值，否则在IE8下面会出现问题(详情)。 1234567891011//不推荐var superman = &#123; default: &#123; clark: &apos;kent&apos;&#125;, private: true&#125;;//推荐var superman =&#123; defaults: &#123; clark: &apos;kent&apos;&#125;, hidden: true&#125;; 使用可读性强的同义词代替保留字 1234567891011121314//不推荐var superman = &#123; class: &apos;alien&apos;&#125;;//不推荐var superman = &#123; klass: &apos;alien&apos;&#125;;//推荐var superman = &#123; type: &apos;alien&apos;&#125;; 数组 新建一个数组的语法 12345//不推荐var items = new Array();//推荐var items = []; 如果你不知道数组的长度可以使用push将元素加入。 1234567var someStack = [];//不推荐someStack[someStack.length] = &apos;something&apos;;//推荐someStack.push(&apos;something&apos;); 当你需要复制一个数组的时候使用slice。jsPerf 1234567891011var len = items.length, itemsCopy = [], i;//不推荐for (i = 0; i &lt; len; i++)&#123; itemsCopy[i] = items[i];&#125;//推荐itemsCopy = items.slice(); 用slice转换伪数组对象到数组 1234function trigger() &#123; var args = Array.prototype.slice.call(arguments); ...&#125; String类型 使用单引号&#39;&#39; 1234567891011//不推荐var name = &quot;Bob Parr&quot;;//推荐var name = &apos;Bob Parr&apos;;//不推荐var fullName - &quot;Bob &quot; + this.lastName;//推荐var fullName = &apos;Bob &apos; + this.lastName; 当字符串长度超过80个时，应该通过字符串连接多行显示。 注意：过度使用字符串连接将会影响性能。jsPerf&amp;Discussion 123456789101112131415161718//不推荐var errorMessage = &apos;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&apos;;//不推荐var errorMessage = &apos;This is a super long error that \\was thrown because of Batman. \\When you stop to think about \\how Batman had anything to do \\with this, you would get nowhere \\fast.&apos;;//推荐var errorMessage = &apos;This is a super long error that &apos; + &apos;was thrown because of Batman.&apos; + &apos;When you stop to think about &apos; + &apos;how Batman had anything to do &apos; + &apos;with this, you would get nowhere &apos; + &apos;fast.&apos;; 当程序建立一个字符串时， 使用join代替字符串连接。特别是在IE下：jsPerf 1234567891011121314151617181920212223242526272829303132333435363738var items, messages, length, i;messages = [&#123; state: &apos;success&apos;, message: &apos;This one worked.&apos;&#125;,&#123; state: &apos;success&apos;, message: &apos;This one worked as well.&apos;&#125;,&#123; state: &apos;error&apos;, message: &apos;This one did not work.&apos;&#125;];length = messages.length;// 不推荐function inbox(messages) &#123; items = &apos;&lt;ul&gt;&apos;; for (i = 0; i &lt; length; i++) &#123; items += &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;; &#125; return items + &apos;&lt;/ul&gt;&apos;;&#125;// 推荐function inbox(messages) &#123; items = []; for (i = 0; i &lt; length; i++) &#123; items[i] = messages[i].message; &#125; return &apos;&lt;ul&gt;&lt;li&gt;&apos; + items.join(&apos;&lt;/li&gt;&lt;li&gt;&apos;) + &apos;&lt;/li&gt;&lt;/ul&gt;&apos;;&#125; 函数 函数表达式： 1234567891011121314// 匿名函数表达式var anonymous = function()&#123; return true;&#125;// 命名函数表达式var named = function named() &#123; return true;&#125;;// 立即执行的函数表达式（IIFE）(function()&#123; console.log(&apos;Welcome to the Internet. Please follow me.&apos;);&#125;)(); 不要将函数声明放在如if/while循环或其他任何语句中。但可以用函数表达式来替代函数声明这么做。一些浏览器可能的确可以在语句中使用函数声明。但是在解析方面的处理各不相同，各种浏览器下兼容性很不好。 注意: ECMA-262定义了一系列的语句，但是函数声明并没有被归类为真正的语句。关于这点可查看ECMA-262的文档 12345678910111213//不推荐if (currentUser)&#123; function test() &#123; console.log(&apos;Nope.&apos;); &#125;&#125;//推荐if (currentUser)&#123; var test = function test() &#123; console.log(&apos;Yup.&apos;); &#125;&#125; arguments 不能作为一个参数的名字， 因为这会覆盖每一个函数内的arguments对象。 123456789//不推荐function nope(name, options, arguments) &#123; // ...stuff...&#125;//推荐function yup(name, options, args) &#123; // ...stuff...&#125; 属性 访问一个属性时，使用点的形式取值。 12345678910var luke = &#123; jedi: true, age: 28&#125;;// 不推荐var isJedi = luke[&apos;jedi&apos;];// 推荐var isJedi = luke.jedi; 需要一个变量访问一个属性时，使用“[]”来取值。 12345678910var luke = &#123; jedi: true, age: 28&#125;;function getProp(prop) &#123; return luke[prop];&#125;var isJedi = getProp(&apos;jedi&apos;); 变量 总是使用 var 来定义变量。如果不这么做将定义一个全局变量出来。我们希望避免全局命名空间的污染。 12345// 不推荐superPower = new SuperPower();// 推荐var superPower = new SuperPower(); 使用一个var 声明多个变量，并且每声明一个变量就换一行。 123456789// 不推荐var items = getItems();var goSportsTeam = true;var dragonball = &apos;z&apos;;// 推荐var items = getItems(), goSportsTeam = true, dragonball = &apos;z&apos;; 声明多个变量时，把不赋值的变量放在后面。这样做是有好处的，如果日后你想给未赋值变量赋值的时候，可能要引用到上面已经赋值的变量。 1234567891011121314151617// 不推荐var i, len, dragonball, items = getItems(), goSportsTeam = true;// 不推荐var i, items = getItems(), dragonball, goSportsTeam = true, len;// 推荐var items = getItems(), goSportsTeam = true, dragonball, length, i; 在一个作用域的顶部给一个变量赋值。这样有助于避开，变量声明和声明提前的分配问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 不推荐function() &#123; test(); console.log(&apos;doing stuff..&apos;); //..other stuff.. var name = getName(); if (name === &apos;test&apos;) &#123; return false; &#125; return name;&#125;// 推荐function() &#123; var name = getName(); test(); console.log(&apos;doing stuff..&apos;); //..other stuff.. if (name === &apos;test&apos;) &#123; return false; &#125; return name;&#125;// 不推荐function() &#123; var name = getName(); if (!arguments.length) &#123; return false; &#125; return true;&#125;// 推荐function() &#123; if (!arguments.length) &#123; return false; &#125; var name = getName(); return true;&#125; 声明提前 不管你在何处给一个变量声明或赋值，javascript解析器都会事先在作用域的顶端做声明提前（Hoisting）。 12345678910111213141516171819// 我们知道下面将不能正常运行（假设没有全局变量）function example() &#123; console.log(notDefined); // =&gt; 抛出一个引用错误&#125;// 在引用这个变量之后，给这个变量赋值将不会抛异常，这是因为javascript解析器有声明提前。// 注意：赋的“true”值，不会被提前。function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// javascript解析器,会在作用域的顶部提前声明变量。// 用代码描述出来，其实就等同于下面这种情况。function example() &#123; var declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125; 匿名函数表达式将该变量名做了提前声明，没有给该变量赋值函数。 123456789function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; 抛出异常，anonymous 不是一个函数 var anonymous = function() &#123; console.log(&apos;anonymous function expression&apos;); &#125;;&#125; 和匿名一样，有名函数表达式将该变量名做了提前声明，没有给该变量赋值函数名和函数体。 12345678910111213141516171819202122function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; 抛出异常， named 不是一个函数 superPower(); // =&gt; 抛出异常， superPower 没定义 var named = function superPower() &#123; console.log(&apos;Flying&apos;); &#125;;&#125;// 把函数名改成和变量名一样，也得出同样的结果。function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; 抛出异常， named 不是一个函数 var named = function named() &#123; console.log(&apos;named&apos;); &#125;;&#125; 函数声明会将函数名和函数体声明提前。 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log(&apos;Flying&apos;); &#125;&#125; 更多信息请参照 Ben Cherry 的 JavaScript Scoping &amp; Hoisting 条件表达式与等式 使用 === 和 !== 代替 == 和 !=。 条件表达式 会通过 ToBoolean 来进行强制转化，而且遵循以下的规则： 对象被转化为true Undefined被转化为false Null被转化为false 布尔值被转化为相应的布尔值 数字当值为+0,-0或NaN时转化为false，其他的转化为true Strings类型如果为空时转化为false,否则转化为true 1234if ([0]) &#123; // true // 因为数组是对象，对象会被转化为 true&#125; 使用快捷方式 12345678910111213141516171819// 不推荐if (name !== &apos;&apos;) &#123; // ...stuff...&#125;// 推荐if (name) &#123; // ...stuff...&#125;// 不推荐if (collection.length &gt; 0) &#123; // ...stuff...&#125;// 推荐if (collection.length) &#123; // ...stuff...&#125; 更多的信息 请看 Angus Croll 的 Truth Equality and JavaScript 块 给多行的块，使用大括号 12345678910111213141516171819// 不推荐if (test) return false;// 推荐if (test) return false;// 推荐if (test) &#123; return false;&#125;// 不推荐function() &#123; return false; &#125;// 推荐function() &#123; return false;&#125; 注释 使用 /**...*/ 进行多行注释。注释要包括描述、指定类型、参数值和返回值。 12345678910111213141516171819202122232425262728// 不推荐// make() returns a new element// based on the passed in tag name//// @param &lt;String&gt; tag// @return &lt;Element&gt; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// 推荐/** * make() returns a new element * based on the passed in tag name * * @param &lt;String&gt; tag * @return &lt;Element&gt; element */function make(tag) &#123; // ...stuff... return element;&#125; 使用 // 进行单行注释。注释单独占一行，并写在需要注释对象的上面。在注释的上面留一个空行。 12345678910111213141516171819202122232425// 不推荐var active = true; // is current tab// 推荐// is current tabvar active = true;// 不推荐function getType() &#123; console.log(&apos;fetching type...&apos;); // set the default type to &apos;no type&apos; var type = this._type || &apos;no type&apos;; return type;&#125;// 推荐function getType() &#123; console.log(&apos;fetching type...&apos;); // set the default type to &apos;no type&apos; var type = this._type || &apos;no type&apos;; return type;&#125; 给你的代码加前缀，比如FIXME或TODO，这样有助于其他开发者可以迅速理解你指出的需要被处理的问题。如果想更清晰一点你还可以在后面加上描述，比如: FIXME -- need to figure this out或TODO -- need to implement. 使用 // FIXME: 去注释问题 1234567function Calculator() &#123; // FIXME: shouldn&apos;t use a global here total = 0; return this;&#125; 使用 // TODO: 来注释解决方法 1234567function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; 空格 将tab键设成2个空格 123456789101112131415// 不推荐function() &#123;∙∙∙∙var name;&#125;// 不推荐function() &#123;∙var name;&#125;// 推荐function() &#123;∙∙var name;&#125; 逗号/冒号/小括号后面留一个空格 123456789101112131415161718192021// 不推荐function test()&#123; console.log(&apos;test&apos;);&#125;// 推荐function test() &#123; console.log(&apos;test&apos;);&#125;// 不推荐dog.set(&apos;attr&apos;,&#123; age: &apos;1 year&apos;, breed: &apos;Bernese Mountain Dog&apos;&#125;);// 推荐dog.set(&apos;attr&apos;, &#123; age: &apos;1 year&apos;, breed: &apos;Bernese Mountain Dog&apos;&#125;); 在文件的最后留一个空行 1234// 不推荐(function(global) &#123; // ...stuff...&#125;)(this); 1234// 推荐(function(global) &#123; // ...stuff...&#125;)(this); 逗号 逗号不要前置 12345678910111213141516171819202122232425// 不推荐var once , upon , aTime;// 推荐var once, upon, aTime;// 不推荐var hero = &#123; firstName: &apos;Bob&apos; , lastName: &apos;Parr&apos; , heroName: &apos;Mr. Incredible&apos; , superPower: &apos;strength&apos;&#125;;// 推荐var hero = &#123; firstName: &apos;Bob&apos;, lastName: &apos;Parr&apos;, heroName: &apos;Mr. Incredible&apos;, superPower: &apos;strength&apos;&#125;; 最后一个元素不可以加逗号。这在IE6和IE7还有IE9的怪异模式下出错。 关于","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"ES6编程风格","slug":"ES6编码风格","date":"2017-02-12T08:12:11.000Z","updated":"2017-08-21T09:52:30.892Z","comments":true,"path":"2017/02/12/ES6编码风格/","link":"","permalink":"http://yoursite.com/2017/02/12/ES6编码风格/","excerpt":"","text":"ES6编程风格编程风格本章探讨如何将ES6的新语法，运用到编码实践之中，与传统的JavaScript语法结合在一起，写出合理的、易于阅读和维护的代码。 多家公司和组织已经公开了它们的风格规范，具体可参阅jscs.info，下面的内容主要参考了Airbnb的JavaScript风格规范。 块级作用域（1）let 取代 var ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。 123456789&apos;use strict&apos;;if (true) &#123; let x = &apos;hello&apos;;&#125;for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。 var命令存在变量提升效用，let命令没有这个问题。 123456&apos;use strict&apos;;if(true) &#123; console.log(x); // ReferenceError let x = &apos;hello&apos;;&#125; 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。 所以，建议不再使用var命令，而是使用let命令取代。 （2）全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提供程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。 12345678910// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。 所有的函数都应该设置为常量。 长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 1234567891011// badconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// acceptableconst c = `foobar`;// goodconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 1234567891011121314// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 1234567891011// badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 12345678910111213// badconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123; id: 5, name: &apos;San Francisco&apos;, [getKey(&apos;enabled&apos;)]: true,&#125;; 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 1234567891011121314151617181920212223var ref = &apos;some value&apos;;// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 数组使用扩展运算符（…）拷贝数组。 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组。 12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 函数立即执行函数可以写成箭头函数的形式。 123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。 123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。 1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。 123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; Map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。 12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。 1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 使用export取代module.exports。 123456789101112131415161718192021// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;const Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);export default Breadcrumbs 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 12345// badimport * as myObject &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。 1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。 123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide; ESLint的使用ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 首先，安装ESLint。 1$ npm i -g eslint 然后，安装Airbnb语法规则。 1$ npm i -g eslint-config-airbnb 最后，在项目的根目录下新建一个.eslintrc文件，配置ESLint。 123&#123; &quot;extends&quot;: &quot;eslint-config-airbnb&quot;&#125; 现在就可以检查，当前项目的代码是否符合预设的规则。 index.js文件的代码如下。 12345678var unusued = &apos;I have no purpose!&apos;;function greet() &#123; var message = &apos;Hello, World!&apos;; alert(message);&#125;greet(); 使用ESLint检查这个文件。 1234567$ eslint index.jsindex.js 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 5:5 error Expected indentation of 2 characters but found 4 indent✖ 3 problems (3 errors, 0 warnings) 上面代码说明，原文件有三个错误，一个是定义了变量，却没有使用，另外两个是行首缩进为4个空格，而不是规定的2个空格。","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"SASS用法指南","slug":"SASS用法指南","date":"2017-02-10T03:42:31.000Z","updated":"2017-08-21T09:45:25.544Z","comments":true,"path":"2017/02/10/SASS用法指南/","link":"","permalink":"http://yoursite.com/2017/02/10/SASS用法指南/","excerpt":"","text":"SASS用法指南 学过CSS的人都知道，它不是一种编程语言。你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。很自然地，有人就开始为CSS加入编程元素，这被叫做”CSS预处理器”（css preprocessor）。它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。各种”CSS预处理器”之中，我自己最喜欢SASS，觉得它有很多优点，打算以后都用它来写CSS。下面是我整理的用法总结，供自己开发时参考，相信对其他人也有用。 什么是SASSSASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。本文总结了SASS的主要用法。我的目标是，有了这篇文章，日常的一般使用就不需要去看官方文档了。 安装和使用安装SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先安装Ruby，然后再安装SASS。假定你已经安装好了Ruby，接着在命令行输入下面的命令： gem install sass然后，就可以使用了。 使用SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。下面的命令，可以在屏幕上显示.scss文件转化的css代码。（假设文件名为test。） sass test.scss如果要将显示结果保存成文件，后面再跟一个.css文件名。 sass test.scss test.cssSASS提供四个编译风格的选项： nested：嵌套缩进的css代码，它是默认值。 expanded：没有缩进的、扩展的css代码。 compact：简洁格式的css代码。 compressed：压缩后的css代码。生产环境当中，一般使用最后一个选项。 sass –style compressed test.sass test.css你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。 // watch a file sass –watch input.scss:output.css // watch a directory sass –watch app/sass:public/stylesheets SASS的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。 基本用法变量SASS允许使用变量，所有变量以$开头。 $blue : #1875e7; div { color : $blue; } 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。 $side : left; .rounded { border-#{$side}-radius: 5px; } 计算功能SASS允许在代码中使用算式： body { margin: (14px/2); top: 50px + 100px; right: $var * 10%; } 嵌套SASS允许选择器嵌套。比如，下面的CSS代码： div h1 { color : red; }可以写成： div { hi { color:red; } }属性也可以嵌套，比如border-color属性，可以写成： p { border: { color: red; } }注意，border后面必须加上冒号。在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类，可以写成： a { &amp;:hover { color: #ffb3ff; } } 注释SASS共有两种注释风格。标准的CSS注释 / comment /，会保留到编译后的文件。单行注释 // comment，只保留在SASS源文件中，编译后被省略。在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 /! 重要注释！ / 代码的重用继承SASS允许一个选择器，继承另一个选择器。比如，现有class1： .class1 { border: 1px solid #ddd; }class2要继承class1，就要使用@extend命令： .class2 { @extend .class1; font-size:120%; } MixinMixin有点像C语言的宏（macro），是可以重用的代码块。使用@mixin命令，定义一个代码块。 @mixin left { float: left; margin-left: 10px; }使用@include命令，调用这个mixin。 div { @include left; }mixin的强大之处，在于可以指定参数和缺省值。 @mixin left($value: 10px) { float: left; margin-right: $value; }使用的时候，根据需要加入参数： div { @include left(20px); }下面是一个mixin的实例，用来生成浏览器前缀。 @mixin rounded($vert, $horz, $radius: 10px) { border-#{$vert}-#{$horz}-radius: $radius; -moz-border-radius-#{$vert}#{$horz}: $radius; -webkit-border-#{$vert}-#{$horz}-radius: $radius; }使用的时候，可以像下面这样调用： #navbar li { @include rounded(top, left); } #footer { @include rounded(top, left, 5px); } 颜色函数SASS提供了一些内置的颜色函数，以便生成系列颜色。 lighten(#cc3, 10%) // #d6d65c darken(#cc3, 10%) // #a3a329 grayscale(#cc3) // #808080 complement(#cc3) // #33c 插入文件@import命令，用来插入外部文件。 @import “path/filename.scss”;如果插入的是.css文件，则等同于css的import命令。 @import “foo.css”; 高级用法条件语句@if可以用来判断： p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 &lt; 3 { border: 2px dotted; } }配套的还有@else命令： @if lightness($color) &gt; 30% { background-color: #000; } @else { background-color: #fff; } 循环语句SASS支持for循环： @for $i from 1 to 10 { .border-#{$i} { border: #{$i}px solid blue; } }也支持while循环： $i: 6; @while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; }each命令，作用与for类似： @each $member in a, b, c, d { .#{$member} { background-image: url(“/image/#{$member}.jpg”); } } 自定义函数SASS允许用户编写自己的函数。 @function double($n) { @return $n * 2; } #sidebar { width: double(5px); }","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"sass","slug":"sass","permalink":"http://yoursite.com/tags/sass/"}]},{"title":"vim入坑指南","slug":"vim入坑指南","date":"2016-12-14T02:04:38.000Z","updated":"2017-08-16T05:03:38.027Z","comments":true,"path":"2016/12/14/vim入坑指南/","link":"","permalink":"http://yoursite.com/2016/12/14/vim入坑指南/","excerpt":"","text":"vim入坑指南什么是VIMVim是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和Emacs并列成为类Unix系统用户最喜欢的文本编辑器。 vim的设计理念命令组合:Vim强大的编辑能力中很大部分是来自于其普通模式命令。vim的设计理念是命令的组合。例如普通模式命令”dd”删除当前行，”dj”代表删除到下一行,原理是第一个”d”含义是删除,”j”键代表移动到下一行,组合后”dj”删除当前行和下一行。另外还可以指定命令重复次数，”2dd”（重复”dd”两次），和”dj”的效果是一样的。”d^”,”^”代表行首,故组合后含义是删除到光标开始到行首间的内容(不包含光标);”d$” $”代表行尾,删除到行尾的内容(包含光标);用户学习了各种各样的文本间移动/跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。 模式间的组合:在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按”a”（append/追加）键或者”i”（insert/插入）键。 Vim三种模式插入模式：即 insert 模式，用来输入文本；编辑模式：用以执行命令，也称为正常模式，也是进入Vim的缺省模式；命令模式：用来执行冒号命令。进入Vim后会直接进入编辑模式，接下来按下i进入插入模式，可以输入字符，按下键将从插入模式转换到编辑模式，该模式用于移动和操纵文本。在编辑模式下输入:即可进入命令模式，可以进行保存、查找、替换、配置Vim操作等。 按键功能在Vim的编辑模式下，一些常用的按键都变成了功能键，并且与大家在Windows下常用的快捷键完全不同，在这里，总结一些初学Vim所用的按键功能： 按键 功能 h或← 光标左移 l或→ 光标右移 k或↑ 光标上移 j或↓ 光标下移 gg 快速定位到文本开头 G（shift+g） 快速定位到文本最后一段 0或home 快速定位到当前段首 $或end 快速定位到当前段首 Ctrl+f 向下翻一页 Ctrl+b 向上翻一页 Ctrl+d 向下翻半页 Ctrl+u 向上翻一页 /string 查找文本中光标位置下方的string字符串，如要查找kabc则直接输入/kabc即可 ?string 查找文本中光标位置上方的string字符串，如要查找kabc则直接输入?kabc即可 yy 复制光标所在的段落 y0 复制光标位置到段首的所有字符 y$ 复制光标位置到段尾的所有字符 nyy 从光标位置向下复制n段，包含光标所在的段落 ygg 复制光标位置所在段落到文本开头的所有内容 yG 复制光标位置所在段落到文本结尾的所有内容 p 将复制的内容粘贴为光标所在段落的下一段 P 将复制的内容粘贴为光标所在段落的上一段 dd 删除光标所在的段落 d0 删除光标位置到段首的所有字符 d$ 删除光标位置到段尾的所有字符 dgg 删除光标位置所在段落到文本开头的所有内容 dG 删除光标位置所在段落到文本结尾的所有内容 ndd 从光标位置向下删除n段，包含光标所在的段落 u 撤销上一个操作 Ctrl+r 重复上一个操作 :w 保存数据 :w! 保存时强制写入数据，不管文件是否为只读文件 :q 关闭Vim :q! 关闭Vim，对所做的修改不做保存 :wq 保存数据后关闭Vim :wq! 强制保存数据并关闭Vim","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"git操作详解","slug":"git操作详解","date":"2016-12-10T11:42:31.000Z","updated":"2017-08-21T09:31:50.031Z","comments":true,"path":"2016/12/10/git操作详解/","link":"","permalink":"http://yoursite.com/2016/12/10/git操作详解/","excerpt":"","text":"Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。git clone、git remote、git fetch、git pull、git push 本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。 git clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 $ git clone &lt;版本库的网址&gt; 比如，克隆jQuery的版本库。 $ git clone https://github.com/jquery/jquery.git 该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。 $ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。 $ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git$ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/SSH协议还有另一种写法。 $ git clone [user@]example.com:path/to/repo.git/通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。 git remote为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。不带选项的时候，git remote命令列出所有远程主机。 $ git remoteorigin使用-v选项，可以参看远程主机的网址。 $ git remote -vorigin git@github.com:jquery/jquery.git (fetch)origin git@github.com:jquery/jquery.git (push)上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。 $ git clone -o jQuery https://github.com/jquery/jquery.git$ git remotejQuery上面命令表示，克隆的时候，指定远程主机叫做jQuery。git remote show命令加上主机名，可以查看该主机的详细信息。 $ git remote show &lt;主机名&gt;git remote add命令用于添加远程主机。 $ git remote add &lt;主机名&gt; &lt;网址&gt;git remote rm命令用于删除远程主机。 $ git remote rm &lt;主机名&gt;git remote rename命令用于远程主机的改名。 $ git remote rename &lt;原主机名&gt; &lt;新主机名&gt; git fetch一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。 $ git fetch &lt;远程主机名&gt;上面命令将某个远程主机的更新，全部取回本地。git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 $ git fetch &lt;远程主机名&gt; &lt;分支名&gt;比如，取回origin主机的master分支。 $ git fetch origin master所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。 $ git branch -rorigin/master $ git branch -a masterremotes/origin/master上面命令表示，本地主机的当前分支是master，远程分支是origin/master。取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 $ git checkout -b newBrach origin/master上面命令表示，在origin/master的基础上，创建一个新分支。此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。 $ git merge origin/master或者$ git rebase origin/master上面命令表示在当前分支上，合并origin/master。 git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 $ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 $ git pull origin next:master如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 $ git pull origin next上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 $ git fetch origin$ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。Git也允许手动建立追踪关系。 git branch –set-upstream master origin/next上面命令指定master分支追踪origin/next分支。如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 $ git pull origin上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以省略。 $ git pull上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用rebase模式，可以使用–rebase选项。 $ git pull –rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 $ git pull -p等同于下面的命令$ git fetch –prune origin$ git fetch -p git pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。 $ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 $ git push origin master上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 $ git push origin :master等同于$ git push origin –delete master上面命令表示删除origin主机的master分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 $ git push origin上面命令表示，将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。 $ git push如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 $ git push -u origin master上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 $ git config –global push.default matching或者$ git config –global push.default simple还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。 $ git push –all origin上面命令表示，将所有本地分支都推送到origin主机。如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。 $ git push –force origin上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。最后，git push不会推送标签（tag），除非使用–tags选项。$ git push origin –tags","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"markdown学习笔记","slug":"markdown学习笔记","date":"2016-10-22T06:56:10.000Z","updated":"2017-08-16T05:39:37.523Z","comments":true,"path":"2016/10/22/markdown学习笔记/","link":"","permalink":"http://yoursite.com/2016/10/22/markdown学习笔记/","excerpt":"","text":"简介Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 用途Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。 Markdown 官方文档 创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 Markdown 语法标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 #一级标题 ##二级标题 ###三级标题 一级标题 二级标题 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。只需要在文本前加入 &gt; 这种尖括号（大于号）即可 例如这样 例如这样 图片与链接插入链接与插入图片的语法很像，区别在一个 !号 图片为：{ImgCap}{/ImgCap} 链接为： 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。 例如： 这里是粗体 这里是斜体 表格 效果 语法 Blod text Emphasize text Strike-through text Link title Inline Code code Image alt List * item Blockquote &gt; quote 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。 分割线分割线的语法只需要三个 * 号。 markdown api饥人谷markdwon api:http://api.jirengu.com/#markdown","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"指南","slug":"指南","permalink":"http://yoursite.com/tags/指南/"}]},{"title":"HTML5音频可视化","slug":"HTML5音频可视化","date":"2015-12-19T13:12:55.000Z","updated":"2017-08-16T07:47:22.370Z","comments":true,"path":"2015/12/19/HTML5音频可视化/","link":"","permalink":"http://yoursite.com/2015/12/19/HTML5音频可视化/","excerpt":"","text":"HTML5音频可视化2015年过的可是真快，眼睛一闭一睁，一睁一闭…… 突然发现这一年自己完成了从一个（只会写写黑窗口程序，刷刷acm题目）的菜鸟级程序猿到前端初级攻城狮的升级。就像是经过了累年的蹲马步，站木桩式的修行，终于突破了基本功修炼瓶颈，进入到了一个新的武学世界。开始可以玩玩更加酷炫的东西了…… 话说回来，想当初在读高中的时候，看到天天动听，realplayer做出来的音频可视化效果非常的酷炫，也很想知道这种效果怎么做出来的。而正好，这学期的计算机图形学课程设计里正好有这个选题的研究，于是我果断的跳进了这个坑。 话不多说，先上预览地址效果图：HTML5 web audio 选择本地音乐文件 播放效果 实现思路与程序运行流程1.初始化canvas2.显示音频文件选取对话框3.选择要播放的音乐文件，解码音乐文件，4.将解码后的数据通过audioContext对象进行处理得到analyser5.将解析后的analyser数据逐帧显示在canvas画布上，从而获得音乐的逐帧动画。选题所用到的知识点 HTML5 CANVAS绘图操作 HTML5 AUDIO API 文件读取及浏览器同源策略与FileReader 逐帧动画原理requestAnimationFrame 浏览器事件响应 主要代码‘’’javascript window.onload = function () { var HEIGHT = window.innerHeight, WIDTH = window.innerWidth; var canvas = document.getElementById(“canvas”), audioInput = document.getElementById(‘uploadedFile’); var ctx = canvas.getContext(“2d”); var mfile, mfileName; var audioContext = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)(); window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame; function initCanvas() { canvas.height = HEIGHT; canvas.width = WIDTH; canvas.style.backgroundColor = &quot;#fff&quot;; } function loadPanel() { document.getElementById(&quot;panel&quot;).style.top = &quot;150px&quot;; } function outPanel() { document.getElementById(&quot;panel&quot;).style.top = &quot;-150px&quot;; } audioInput.onchange = function () { //这里判断一下文件长度可以确定用户是否真的选择了文件，如果点了取消则文件长度为0 if (audioInput.files.length !== 0) { mfile = audioInput.files[0]; //将文件赋值到Visualizer对象的属性上 mfileName = mfile.name; document.getElementById(&quot;title&quot;).innerHTML = &quot;解码中……*_*&quot;; start(); //获取到文件后，开始程序，这个方法会在后面定义并实现 }; } function start() { var fr = new FileReader(); fr.onload = function (e) { //文件读取完后调用此函数 var fileResult = e.target.result; //这是读取成功得到的结果ArrayBuffer数据 audioContext.decodeAudioData(fileResult, function (buffer) { //解码成功则调用此函数，参数buffer为解码后得到的结果 var audioBufferSouceNode = audioContext.createBufferSource(); var analyser = audioContext.createAnalyser(); audioBufferSouceNode.connect(analyser); analyser.connect(audioContext.destination); audioBufferSouceNode.buffer = buffer; audioBufferSouceNode.start(0); draw(analyser); outPanel(); }, function (e) { document.getElementById(&quot;title&quot;).innerHTML = &quot;文件解码失败:(&quot;; }); }; //将上一步获取的文件传递给FileReader从而将其读取为ArrayBuffer格式 fr.readAsArrayBuffer(mfile); } function draw(analyser) { var cNum = 128; analyser.fftSize = cNum * 2; var Dots = []; function random(m, n) { return Math.round(Math.random() * (n - m) + m); } function getDots() { Dots = []; for (var i = 0; i &lt; cNum; i++) { var x = random(0, canvas.width); var y = random(0, canvas.height); var color = &quot;rgba(&quot; + random(0, 255) + &quot;,&quot; + random(0, 255) + &quot;,&quot; + random(0, 255) + &quot;,&quot; + random(0,10)/10 + &quot;)&quot;; Dots.push({ x: x, y: y, dy: random(0, 2), color: color }); } } getDots(); var drawCircle = function () { var array = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(array); ctx.clearRect(0, 0, WIDTH, HEIGHT); for (var i = 0; i &lt; cNum; i++) { ctx.beginPath(); var o = Dots[i]; var r = array[i] / 256 * 30; if (o.x &gt; canvas.width||o.y&gt;canvas.height) { o.y = 0; } else { o.y = o.y; } ctx.arc(o.x, o.y, r, 0, Math.PI * 2, true); var g = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, r); g.addColorStop(0, &quot;#fff&quot;); g.addColorStop(0.9, &quot;#fff&quot;); g.addColorStop(1, o.color); //g.addColorStop(1, &quot;rgb(114,208,156)&quot;); ctx.fillStyle = g; ctx.fill(); ctx.closePath(); } requestAnimationFrame(drawCircle); } requestAnimationFrame(drawCircle); } initCanvas(); loadPanel(); }‘’’ 参考资料1.File reader in JavaScript2.Audio context from MDN3.Window.requestAnimationFrame4.开大你的音响，感受HTML5 Audio API带来的视听盛宴","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"web audio","slug":"web-audio","permalink":"http://yoursite.com/tags/web-audio/"},{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"纯css实现扁平化360卫士logo","slug":"纯css实现扁平化360卫士logo","date":"2015-12-10T08:42:51.000Z","updated":"2017-08-16T05:50:51.831Z","comments":true,"path":"2015/12/10/纯css实现扁平化360卫士logo/","link":"","permalink":"http://yoursite.com/2015/12/10/纯css实现扁平化360卫士logo/","excerpt":"","text":"纯css实现扁平化360卫士logo前几天在w3ctech上看到有人用纯css写出了360卫士的logo，感觉蛮好玩的。 因为自己用css以来，还没有写过这种玩意，出于娱乐，我也来试着尝试一下。 开始也不知到怎么下手，最棘手的是那两个像太极的东东不好弄。不过，好在以前用过photoshop绘制过一些简单的icon。所以，经过我仔细 的分析。大概有了思路，这两个东东是可以利用box-shadow这个属性来实现。虽然跟photoshop绘制有点不同，但是大致还是差不多的。 代码效果预览地址：http://code.w3ctech.com/detail/2501 对于刚在学习css的同学是个不错的小案例，分享给你们，有兴趣的可以试试。当然，如果有更好的思路的，可以在下面留言，相互探讨，一起进步。","categories":[],"tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"我喜欢出发","slug":"我喜欢出发","date":"2014-08-17T11:54:13.000Z","updated":"2017-08-16T03:58:13.791Z","comments":true,"path":"2014/08/17/我喜欢出发/","link":"","permalink":"http://yoursite.com/2014/08/17/我喜欢出发/","excerpt":"","text":"我喜欢出发——汪国真我喜欢出发。 凡是到达了的地方，都属于昨天。哪怕那山再青，那水再秀，那风再温柔。太深的流连便成了一种羁绊，绊住的不仅有双脚，还有未来。 怎么能不喜欢出发呢?没见过大山的巍峨，真是遗憾；见了大山的巍峨没见过大海的浩瀚仍然遗憾；见了大海的浩瀚没见过大漠的广袤，依旧遗憾；见了大漠的广袤没见过森林的神秘，还是遗憾。世界上有不绝的风景，我有不老的心情。 我自然知道，大山有坎坷，大海有浪涛，大漠有风沙，森林有猛兽。即便这样，我依然喜欢。 打破生活的平静便是另一番景致，一种属于年轻的景致。真庆幸，我还没有老。即便真老了又怎么样，不是有句话叫老当益壮吗? 于是，我还想从大山那里学习深刻，我还想从大海那里学习勇敢，我还想从大漠那里学习沉着，我还想从森林那里学习机敏。我想学着品味一种缤纷的人生。 人能走多远?这话不是要问两脚而是要问志向；人能攀多高?这事不是要问双手而是要问意志。于是，我想用青春的热血给自己树起一个高远的目标。不仅是为了争取一种光荣，更是为了追求一种境界。目标实现了，便是光荣；目标实现不了，人生也会因这一路风雨跋涉变得丰富而充实；在我看来，这就是不虚此生。 是的，我喜欢出发，愿你也喜欢。 每次看完这篇文章，心情都会舒畅很多，很多的不快和忧愁便会如烟散去。 想到自己还有那么多的事情没有去做，没有去尝试，就觉得自己应该坚强起来，坚持，勇敢的去一步一步的朝目标前进。虽然不知道前方等待我的是什么，但正如作者所说:”只要热爱生命，一切都在意料之中“。 是的，我也喜欢出发，喜欢去探索新的生活。","categories":[],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"}]},{"title":"Hello World","slug":"hello-world","date":"2014-07-11T08:24:56.000Z","updated":"2017-08-16T04:00:18.922Z","comments":true,"path":"2014/07/11/hello-world/","link":"","permalink":"http://yoursite.com/2014/07/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}